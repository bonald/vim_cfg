#ifndef __SFLOW_H__
#define __SFLOW_H__

#define SFLOW_MAXCOLLECTOR              2

#define SFLOW_COUNTER_STEP              1

#define SFLOW_MAX_HEADERSIZE            256
#define SFLOW_DEFAULT_MAX_HEADERSIZE    SFLOW_MAX_HEADERSIZE
#define SFLOW_LOG_INTERVAL            10
#define SFLOW_LOG_MAX            3
/* Sampled header data must be a multiple of 4 */
#define SFLOW_HEADER_ALIGNMENT          4

#define SFLOW_LOG_EMERG(fmt, args...)    log_sys(M_MOD_SFLOW, E_EMERGENCY, fmt, ##args)
#define SFLOW_LOG_ALERT(fmt, args...)    log_sys(M_MOD_SFLOW, E_ALERT, fmt, ##args)
#define SFLOW_LOG_CRIT(fmt, args...)     log_sys(M_MOD_SFLOW, E_CRITICAL, fmt, ##args)
#define SFLOW_LOG_ERR(fmt, args...)      log_sys(M_MOD_SFLOW, E_ERROR, fmt, ##args)
#define SFLOW_LOG_WARN(fmt, args...)     log_sys(M_MOD_SFLOW, E_WARNING, fmt, ##args)
#define SFLOW_LOG_NOTICE(fmt, args...)   log_sys(M_MOD_SFLOW, E_NOTICE, fmt, ##args)
#define SFLOW_LOG_INFO(fmt, args...)     log_sys(M_MOD_SFLOW, E_INFORMATIONAL, fmt, ##args)

#define SNMP_PROMISC_TRUE         1
#define SNMP_PROMISC_FALSE        2

/* defines for interface hardware type */
#define SNMP_INTERFACE_ETHERNETCSMACD             6
#define SNMP_INTERFACE_PPP                        23
#define SNMP_INTERFACE_TUNNEL                    131
#define SNMP_INTERFACE_VLANIF                    136
#define SNMP_INTERFACE_AGG                       161

#define SFLOW_DISPLAY_LEN         81

bool sflow_debug_is_on(uint32 flag);

#define SFLOW_LOG_DEBUG(flag, fmt, args...) \
do { \
    if (sflow_debug_is_on(flag)) \
        log_sys(M_MOD_SFLOW, E_DEBUG, fmt, ##args); \
} while (0)

#define ETH_P_8021Q 0x8100
#define SFLOW_IP_PACKET 0x0800
typedef struct {
    uint32 addr;
} SFLIPv4;

typedef struct {
     uint8 addr[16];
} SFLIPv6;

typedef union _SFLAddress_value {
    SFLIPv4 ip_v4;
    SFLIPv6 ip_v6;
} SFLAddress_value;





struct sflow_packet_sample
{
    uint32 sample_type; /* SFLOW_FLOW_SAMPLE or SFLOW_COUNTER_SAMPLE */
    uint8  sample_data[0];    
};

struct sflow_packet_flow_sample
{
    uint32 sequence_number;      /* Incremented with each flow sample
                                                               generated */
    uint32 source_id;          
    uint32 sampling_rate;        
    uint32 sample_pool;          /* Total number of packets that could have been
                                                         sampled (i.e. packets skipped by sampling
                                                         process + total number of samples) */
    uint32 drops;                /* Number of times a packet was dropped due to
                                                     lack of resources */
    uint32 input;                /* SNMP ifIndex of input interface.
                                                     0 if interface is not known. */
    uint32 output;               /* SNMP ifIndex of output interface,
                                                    0 if interface is not known.
                                                    Set most significant bit to indicate
                                                    multiple destination interfaces
                                                    (i.e. in case of broadcast or multicast)
                                                    and set lower order bits to indicate
                                                    number of destination interfaces.
                                                    Examples:
                                                    0x00000002  indicates ifIndex = 2
                                                    0x00000000  ifIndex unknown.
                                                    0x80000007  indicates a packet sent
                                                    to 7 interfaces.
                                                    0x80000000  indicates a packet sent to
                                                    an unknown number of
                                                    interfaces greater than 1.*/
    uint8 packet_data[0];
};

/* add by yejl for sflow v5*/
/* Expanded flow sample */
struct sflow_packet_flow_sample_expanded
{
    uint32 sequence_number;  /* Incremented with each flow sample
                                                    generated by this source_id.
                                                    Note: If the agent resets the
                                                            sample_pool then it must
                                                            also reset the sequence_number.*/
    uint32 source_id_type;      /* sFlowDataSource type, type = 0, source_id_index is ifIndex*/
    uint32 source_id_index;     /* sFlowDataSource index */
    uint32 sampling_rate;        /* sFlowPacketSamplingRate */
    uint32 sample_pool;          /* Total number of packets that could have
                                                    been sampled (i.e. packets skipped by
                                                    sampling process + total number of
                                                    samples) */
    uint32 drops;                     /* Number of times that the sFlow agent
                                                    detected that a packet marked to be
                                                    sampled was dropped due to
                                                    lack of resources. The drops counter
                                                    reports the total number of drops
                                                    detected since the agent was last reset.
                                                    A high drop rate indicates that the
                                                    management agent is unable to process
                                                    samples as fast as they are being
                                                    generated by hardware. Increasing
                                                    sampling_rate will reduce the drop
                                                    rate. Note: An agent that cannot
                                                    detect drops will always report
                                                    zero. */
    uint32 input_format;          /* interface format    0:single interface*/
    uint32 input_value;            /* interface value, format = 1 -> value is ifIndex */
    uint32 output_format;        /* interface format  1:packet discarded, 2:multiple destination interfaces*/
    uint32 output_value;         /* interface value, format = 2 -> value is num of output if */
    uint32 flow_records_num;
};

/* raw packet header */
struct sflow_flow_raw_packet_header
{
    uint32 header_protocol;  /* Format of sampled header */
    uint32 frame_length;      /* Original length of packet before sampling */
    uint32 stripped;             /* The number of octets removed from
                                                the packet before extracting the
                                                header<> octets. Trailing encapsulation
                                                data corresponding to any leading
                                                encapsulations that were stripped must
                                                also be stripped. Trailing encapsulation
                                                data for the outermost protocol layer
                                                included in the sampled header must be
                                                stripped.
                                                In the case of a non-encapsulated 802.3
                                                packet stripped >= 4 since VLAN tag
                                                information might have been stripped off
                                                in addition to the FCS.
                                                Outer encapsulations that are ambiguous,
                                                or not one of the standard header_protocol
                                                must be stripped. 
                                                stripped_length = frame_length - header_length */
    uint32 header_length;    /* Header bytes = frame_original_len or maxheadersize(256)*/
};

/* Expanded frame data */
struct sflow_flow_expanded_frame_data
{
    uint32 length_mac_packet;     /* The length of the MAC packet received on the
                                                        network, excluding lower layer encapsulations
                                                        and framing bits but including FCS octets */
    uint8  src_mac[8];             /* Source MAC address */
    uint8  dst_mac[8];             /* Destination MAC address */
    uint32 ethernet_packet_type;  /* Ethernet packet type   0x0806:ARP */
};


enum IP_protocol_type//add by yangl
{
    SFLOW_PROTO_ICMP    = 1,
    SFLOW_PROTO_IGMP    = 2,
    SFLOW_PROTO_TCP     = 6,
    SFLOW_PROTO_UDP     = 17,
    SFLOW_PROTO_IGRP    = 88,
    SFLOW_PROTO_OSPF    = 89
};

enum IP_type//add by yangl
{
    SFLOW_IP_V4 = 1,
    SFLOW_IP_V6 = 2
};


struct sflow_flow_sample_ipv4_data//add by yangl
{

  
uint32 length;     /* The length of the IP packet excluding  lower layer encapsulations */
uint32 protocol;   /* IP Protocol type
                              (for example, TCP = 6, UDP = 17) */
addr_ipv4_t src_ip;            /* Source IP Address */
addr_ipv4_t dst_ip;            /* Destination IP Address */
uint32  src_port;   /* TCP/UDP source port number or
                               equivalent */
uint32  dst_port;   /* TCP/UDP destination port number or
                               equivalent */
uint32  tcp_flags;  /* TCP flags */
uint32  tos;        /* IP type of service */
};


struct sflow_flow_extended_router_data//add by   yangl 
{
   uint32 IP_type;
   addr_ipv4_t nexthop;       /* IP address of next hop router */
   uint32 src_mask;   /* Source address prefix mask bits */
   uint32 dst_mask;   /* Destination address prefix mask bits */
};


/* Expanded switch data */
struct sflow_flow_expanded_switch_data
{
    uint32 src_vlan;
    uint32 src_priority;
    uint32 dst_vlan;
    uint32 dst_priority;
};


struct sflow_flow_sample_packet
{
    uint32 flow_sample_type; /* only SFLOW_FLOW_HEADER supported */ 
    uint8  flowdate[0];
};

struct sflow_flow_sample_header
{
    uint32 protocol;  /* Only SFLOW_FLOW_HEADER_ISO8023 supported */
    uint32 frame_length; /* Original length of packet before sampling */
    uint32 sampled_length; /* Actually sampled packet length */
    uint8  data[0];
};

struct sflow_flow_extended_info
{
    uint32 type;    /* only SFLOW_FLOW_EXTENDED_SWITCH now */
    uint8  data[0];
};

struct sflow_flow_extended_switch
{
    uint32 srv_vlan;
    uint32 src_priority;
    uint32 dst_vlan;
    uint32 dst_priority;    
};

struct sflow_packet_counter_sample
{
    uint32 sequence_number;    /* Incremented with each counters sample  
                                                             generated by this source_id */
    uint32 source_id;
    uint32 sampling_interval;
    uint32 counter_type;
    uint8  counter_data[0];
};

/* Expanded Counter Sample */
struct sflow_packet_counter_sample_expanded
{
    uint32_t sequence_number;    /* Incremented with each counters sample  
                                                             generated by this source_id */
    uint32_t source_id_type;      /* sFlowDataSource type, type = 0, source_id_index is ifIndex*/
    uint32_t source_id_index;     /* sFlowDataSource index */
    uint32_t counter_records_num;
};

/* Definition for sFlow packet */
struct sflow_packet_if_couters
{
  uint32 ifIndex;
  uint32 ifType;
  uint64 ifSpeed;
  uint32 ifDirection;   /* Derived from MAU MIB (RFC 2668) 0 = unknown, 1 = full-duplex,
                           2 = half-duplex, 3 = in, 4 = out */
  uint32 ifStatus;   /* bit field with the following bits assigned:
                           bit 0 = ifAdminStatus (0 = down, 1 = up)
                           bit 1 = ifOperStatus (0 = down, 1 = up) */
  uint64 ifInOctets;
  uint32 ifInUcastPkts;
  uint32 ifInMulticastPkts;
  uint32 ifInBroadcastPkts;
  uint32 ifInDiscards;
  uint32 ifInErrors;
  uint32 ifInUnknownProtos;
  uint64 ifOutOctets;
  uint32 ifOutUcastPkts;
  uint32 ifOutMulticastPkts;
  uint32 ifOutBroadcastPkts;
  uint32 ifOutDiscards;
  uint32 ifOutErrors;
  uint32 ifPromiscuousMode;
};

#define SFLOW_COUNTER_SAMPLE_SIZE (sizeof(struct sflow_packet_sample)+sizeof(struct sflow_packet_counter_sample)+sizeof(struct sflow_packet_if_couters))

/* added by yejl for sflow version 5*/
#define SFLOW_COUNTER_SAMPLE_SIZE_VERSION5 (8 + sizeof(struct sflow_packet_counter_sample_expanded) + 8 + sizeof(struct sflow_packet_if_couters))
struct sflow_datagram_v4_inet
{
    uint32 version;
    uint32 address_type;    /* SFLOW_ADDRESS_IP_V4 */
    struct sal_in4_addr agentipaddr;  
    uint32 sequence_number;        /* Incremented with each sample datagram generated */
    uint32 uptime;                /* Current time (in milliseconds since device
                                                      last booted). Should be set as close to
                                                      datagram transmission time as possible.*/
    uint32 sample_num;       /* Number of tag-len-val flow/counter records to follow */
    uint8  samples[0];
};

/* added by yejl for sflow version 5*/
struct sflow_datagram_v5_inet
{
    uint32 version;                       /* SFLOW_VERSION5 */
    uint32 address_type;              /* SFLOW_ADDRESS_IP_V4 */
    struct sal_in4_addr agentipaddr;
    uint32 sub_agent_id;             /* Used to distinguishing between datagram                                     
                                                        streams from separate agent sub entities
                                                        within an device. */
    uint32 sequence_number;     /* Incremented with each sample datagram generated */
    uint32 uptime;                      /* Current time (in milliseconds since device
                                                       last booted). Should be set as close to
                                                       datagram transmission time as possible.*/
    uint32 sample_num;             /* Number of tag-len-val flow/counter records to follow */
    uint8  samples[0];
};

/* modified by liwh for bug 53920, 2019-10-12 */
struct sflow_datagram_v4_inet6
{
    uint32 version;
    uint32 address_type;    /* SFLOW_ADDRESS_IP_V6 */
    struct sal_in6_addr agentipaddr;  
    uint32 sequence_number;        /* Incremented with each sample datagram generated */
    uint32 uptime;                /* Current time (in milliseconds since device
                                                      last booted). Should be set as close to
                                                      datagram transmission time as possible.*/
    uint32 sample_num;       /* Number of tag-len-val flow/counter records to follow */
    uint8  samples[0];
};

struct sflow_datagram_v5_inet6
{
    uint32 version;                       /* SFLOW_VERSION5 */
    uint32 address_type;              /* SFLOW_ADDRESS_IP_V6 */
    struct sal_in6_addr agentipaddr;
    uint32 sub_agent_id;             /* Used to distinguishing between datagram                                     
                                                        streams from separate agent sub entities
                                                        within an device. */
    uint32 sequence_number;     /* Incremented with each sample datagram generated */
    uint32 uptime;                      /* Current time (in milliseconds since device
                                                       last booted). Should be set as close to
                                                       datagram transmission time as possible.*/
    uint32 sample_num;             /* Number of tag-len-val flow/counter records to follow */
    uint8  samples[0];
};
/* liwh end */

#define SFLOW_ENCODE_PUTL(V)                \
    do {                                    \
        *(pnt) = ((V) >> 24) & 0xFF;       \
        *(pnt + 1) = ((V) >> 16) & 0xFF;   \
        *(pnt + 2) = ((V) >> 8) & 0xFF;    \
        *(pnt + 3) = (V) & 0xFF;           \
         pnt += 4;                          \
        *size += 4;                          \
    } while (0)

#define SFLOW_ENCODE_PUT64(V)                \
        do {                                    \
            *(pnt) = ((V) >> 56) & 0xFF;       \
            *(pnt + 1) = ((V) >> 48) & 0xFF;   \
            *(pnt + 2) = ((V) >> 40) & 0xFF;    \
            *(pnt + 3) = ((V) >> 32) & 0xFF;           \
            *(pnt + 4) = ((V) >> 24) & 0xFF;       \
            *(pnt + 5) = ((V) >> 16) & 0xFF;   \
            *(pnt + 6) = ((V) >> 8) & 0xFF;    \
            *(pnt + 7) = (V) & 0xFF;           \
            pnt += 8;                          \
            *size += 8;                          \
        } while (0)

#define SFLOW_ENCODE_PUT(P, L)                                    \
        do {                                                    \
            sal_memcpy((void*)(pnt), (void*)(P), (L));         \
            pnt += (L);                                        \
            *size += (L);                                       \
        } while (0)

enum sflow_sample_type 
{
    SFLOW_FLOW_SAMPLE = 1,              
    SFLOW_COUNTER_SAMPLE = 2,
    SFLOW_FLOW_SAMPLE_EXPANDED = 3, /* added by yejl for sflow version 5*/
    SFLOW_COUNTER_SAMPLE_EXPANDED = 4, /* added by yejl for sflow version 5*/
};

enum sflow_counter_type 
{
    SFLOW_COUNTER_GENERIC      = 1,
    SFLOW_COUNTER_ETHERNET     = 2,
    SFLOW_COUNTER_TOKENRING    = 3,
    SFLOW_COUNTER_VG           = 4,
    SFLOW_COUNTER_VLAN         = 5
};

#define SFLOW_IFSTATUS_ADMIN  (1 << 0)
#define SFLOW_IFSTATUS_OPER   (1 << 1)

#define SFLOW_TRANSMIT_DELAY 1

enum sflow_version 
{
    SFLOW_VERSION2 = 2,
    SFLOW_VERSION4 = 4,
    SFLOW_VERSION5 = 5, /* added by yejl for sflow version 5*/
};

enum sflow_address_type
{
    SFLOW_ADDRESS_IP_V4 = 1,
    SFLOW_ADDRESS_IP_V6 = 2
};

enum sflow_flow_type 
{
    SFLOW_FLOW_HEADER    = 1,      /* Packet headers are sampled */
    SFLOW_FLOW_IPV4      = 2,      /* IP version 4 data */
    SFLOW_FLOW_IPV6      = 3,      /* IP version 6 data */
};

/*added by yejl for sflow version 5*/
enum sflow_flow_data_format
{
    SFLOW_FLOW_RAW_PACKET_HEADER = 1,                /* Raw Packet Header */
    SFLOW_FLOW_ETHERNET_FRAME_DATA = 2,             /* Ethernet Frame Data */
    SFLOW_FLOW_PACKET_IP_V4_DATA = 3,                  /* Packet IP version 4 data */
    SFLOW_FLOW_PACKET_IP_V6_DATA = 4,                  /* Packet IP Version 6 Data */
    SFLOW_FLOW_EXPENDED_SWITCH_DATA = 1001,      /* Extended Switch Data */
    SFLOW_FLOW_EXPENDED_ROUTER_DATA = 1002,      /* Extended Router Data */
};

enum sflow_flow_header_protocol
{
  SFLOW_FLOW_HEADER_ISO8023           = 1,
  SFLOW_FLOW_HEADER_TOKENBUS        = 2,
  SFLOW_FLOW_HEADER_TOKENRING      = 3,
  SFLOW_FLOW_HEADER_FDDI                = 4,
  SFLOW_FLOW_HEADER_RELAY              = 5, 
  SFLOW_FLOW_HEADER_X25                  = 6,
  SFLOW_FLOW_HEADER_PPP                  = 7,
  SFLOW_FLOW_HEADER_SMDS                 = 8,
  SFLOW_FLOW_HEADER_AAL5                 = 9,
  SFLOW_FLOW_HEADER_AAL5_IP              = 10, /* e.g. Cisco AAL5 mux */
  SFLOW_FLOW_HEADER_IPv4                 = 11,
  SFLOW_FLOW_HEADER_IPv6                 = 12,
  SFLOW_FLOW_HEADER_MPLS                 = 13
};

enum sflow_flow_extended_type
{
    SFLOW_FLOW_EXTENDED_SWITCH = 1,
    SFLOW_FLOW_EXTENDED_ROUTER = 2,
    SFLOW_FLOW_EXTENDED_GATEWAY = 3,
    SFLOW_FLOW_EXTENDED_USER = 4,
    SFLOW_FLOW_EXTENDED_URL = 5,
};

struct sflow_vlan_hdr_s
{
    uint16 tag;
    uint16 proto;
};
typedef struct sflow_vlan_hdr_s sflow_vlan_hdr_t;

extern int32 sflow_start(switch_master_t *master);
#endif


