/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "switch_sai_rpc.h"

gboolean
switch_sai_rpc_if_sai_thrift_set_port_attribute (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t * thrift_attr, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_set_port_attribute (iface, _return, port_id, thrift_attr, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_fdb_entry (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_fdb_entry_t * thrift_fdb_entry, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_fdb_entry (iface, _return, thrift_fdb_entry, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_delete_fdb_entry (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_fdb_entry_t * thrift_fdb_entry, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_delete_fdb_entry (iface, _return, thrift_fdb_entry, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_flush_fdb_entries (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_flush_fdb_entries (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_vlan (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const gint16 vlan_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_vlan (iface, _return, vlan_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_delete_vlan (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const gint16 vlan_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_delete_vlan (iface, _return, vlan_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_add_ports_to_vlan (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_add_ports_to_vlan (iface, _return, vlan_id, thrift_port_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_ports_from_vlan (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_ports_from_vlan (iface, _return, vlan_id, thrift_port_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_get_vlan_stats (switch_sai_rpcIf *iface, GArray ** _return, const gint16 vlan_id, const GArray * counter_ids, const gint32 number_of_counters, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_get_vlan_stats (iface, _return, vlan_id, counter_ids, number_of_counters, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_virtual_router (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_virtual_router (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_virtual_router (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t vr_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_virtual_router (iface, _return, vr_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_route (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_route (iface, _return, thrift_unicast_route_entry, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_route (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_route (iface, _return, thrift_unicast_route_entry, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_router_interface (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_router_interface (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_router_interface (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t rif_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_router_interface (iface, _return, rif_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_next_hop (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_next_hop (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_next_hop (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_next_hop (iface, _return, next_hop_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_next_hop_group (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_next_hop_group (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_next_hop_group (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_next_hop_group (iface, _return, next_hop_group_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_add_next_hop_to_group (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_add_next_hop_to_group (iface, _return, next_hop_group_id, thrift_nexthops, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_next_hop_from_group (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_next_hop_from_group (iface, _return, next_hop_group_id, thrift_nexthops, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_lag (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_lag (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_lag (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t lag_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_lag (iface, _return, lag_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_lag_member (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_lag_member (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_lag_member (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t lag_member_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_lag_member (iface, _return, lag_member_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_stp_entry (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_stp_entry (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_stp_entry (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t stp_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_stp_entry (iface, _return, stp_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_set_stp_port_state (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_set_stp_port_state (iface, _return, stp_id, port_id, stp_port_state, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_get_stp_port_state (switch_sai_rpcIf *iface, sai_thrift_port_stp_port_state_t* _return, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_get_stp_port_state (iface, _return, stp_id, port_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_neighbor_entry (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_neighbor_entry (iface, _return, thrift_neighbor_entry, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_neighbor_entry (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_neighbor_entry (iface, _return, thrift_neighbor_entry, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_get_switch_attribute (switch_sai_rpcIf *iface, sai_thrift_attribute_list_t ** _return, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_get_switch_attribute (iface, _return, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_set_switch_attribute (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_attribute_t * attribute, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_set_switch_attribute (iface, _return, attribute, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_hostif (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_hostif (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_hostif (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t hif_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_hostif (iface, _return, hif_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_hostif_trap_group (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_hostif_trap_group (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_hostif_trap_group (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t trap_group_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_hostif_trap_group (iface, _return, trap_group_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_hostif_trap (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_hostif_trap (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_hostif_trap (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_hostif_trap_id_t trap_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_hostif_trap (iface, _return, trap_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_set_hostif_trap (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_hostif_trap_id_t trap_id, const sai_thrift_attribute_t * thrift_attr, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_set_hostif_trap (iface, _return, trap_id, thrift_attr, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_acl_table (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_acl_table (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_delete_acl_table (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_table_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_delete_acl_table (iface, _return, acl_table_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_acl_entry (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_acl_entry (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_delete_acl_entry (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_entry, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_delete_acl_entry (iface, _return, acl_entry, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_acl_counter (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_acl_counter (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_delete_acl_counter (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_counter_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_delete_acl_counter (iface, _return, acl_counter_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_get_acl_counter_attribute (switch_sai_rpcIf *iface, GPtrArray ** _return, const sai_thrift_object_id_t acl_counter_id, const GArray * thrift_attr_ids, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_get_acl_counter_attribute (iface, _return, acl_counter_id, thrift_attr_ids, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_mirror_session (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_mirror_session (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_mirror_session (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t session_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_mirror_session (iface, _return, session_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_create_policer (switch_sai_rpcIf *iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_create_policer (iface, _return, thrift_attr_list, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_remove_policer (switch_sai_rpcIf *iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t policer_id, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_remove_policer (iface, _return, policer_id, error);
}

gboolean
switch_sai_rpc_if_sai_thrift_get_policer_stats (switch_sai_rpcIf *iface, GArray ** _return, const sai_thrift_object_id_t policer_id, const GArray * counter_ids, GError **error)
{
  return SWITCH_SAI_RPC_IF_GET_INTERFACE (iface)->sai_thrift_get_policer_stats (iface, _return, policer_id, counter_ids, error);
}

GType
switch_sai_rpc_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (switch_sai_rpcIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "switch_sai_rpcIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
switch_sai_rpc_if_interface_init (switch_sai_rpcIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (switch_sai_rpcClient, switch_sai_rpc_client,
                         G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (TYPE_SWITCH_SAI_RPC_IF,
                                                switch_sai_rpc_if_interface_init))

enum _switch_sai_rpcClientProperties
{
  PROP_0,
  PROP_SWITCH_SAI_RPC_CLIENT_INPUT_PROTOCOL,
  PROP_SWITCH_SAI_RPC_CLIENT_OUTPUT_PROTOCOL
};

void
switch_sai_rpc_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  switch_sai_rpcClient *client = SWITCH_SAI_RPC_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_SWITCH_SAI_RPC_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
switch_sai_rpc_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  switch_sai_rpcClient *client = SWITCH_SAI_RPC_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_SWITCH_SAI_RPC_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean switch_sai_rpc_client_send_sai_thrift_set_port_attribute (switch_sai_rpcIf * iface, const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t * thrift_attr, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_set_port_attribute", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_set_port_attribute_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "port_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, port_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_attr), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_set_port_attribute (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_set_port_attribute", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_set_port_attribute", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_set_port_attribute (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t * thrift_attr, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_set_port_attribute (iface, port_id, thrift_attr, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_set_port_attribute (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_fdb_entry (switch_sai_rpcIf * iface, const sai_thrift_fdb_entry_t * thrift_fdb_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_fdb_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_fdb_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_fdb_entry", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_fdb_entry), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i64;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i64 = 0; i64 < thrift_attr_list->len; i64++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i64))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_fdb_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_fdb_entry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_fdb_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_fdb_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_fdb_entry_t * thrift_fdb_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_fdb_entry (iface, thrift_fdb_entry, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_fdb_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_delete_fdb_entry (switch_sai_rpcIf * iface, const sai_thrift_fdb_entry_t * thrift_fdb_entry, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_delete_fdb_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_delete_fdb_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_fdb_entry", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_fdb_entry), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_delete_fdb_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_delete_fdb_entry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_delete_fdb_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_delete_fdb_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_fdb_entry_t * thrift_fdb_entry, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_delete_fdb_entry (iface, thrift_fdb_entry, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_delete_fdb_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_flush_fdb_entries (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_flush_fdb_entries", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_flush_fdb_entries_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i65;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i65 = 0; i65 < thrift_attr_list->len; i65++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i65))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_flush_fdb_entries (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_flush_fdb_entries", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_flush_fdb_entries", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_flush_fdb_entries (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_flush_fdb_entries (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_flush_fdb_entries (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_vlan (switch_sai_rpcIf * iface, const gint16 vlan_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_vlan", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_vlan_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, vlan_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_vlan", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_vlan", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_vlan (iface, vlan_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_vlan (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_delete_vlan (switch_sai_rpcIf * iface, const gint16 vlan_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_delete_vlan", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_delete_vlan_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, vlan_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_delete_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_delete_vlan", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_delete_vlan", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_delete_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_delete_vlan (iface, vlan_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_delete_vlan (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_add_ports_to_vlan (switch_sai_rpcIf * iface, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_add_ports_to_vlan", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_add_ports_to_vlan_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, vlan_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_port_list", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i66;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_port_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i66 = 0; i66 < thrift_port_list->len; i66++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_port_list, i66))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_add_ports_to_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_add_ports_to_vlan", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_add_ports_to_vlan", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_add_ports_to_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_add_ports_to_vlan (iface, vlan_id, thrift_port_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_add_ports_to_vlan (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_ports_from_vlan (switch_sai_rpcIf * iface, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_ports_from_vlan", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_ports_from_vlan_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, vlan_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_port_list", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i67;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_port_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i67 = 0; i67 < thrift_port_list->len; i67++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_port_list, i67))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_ports_from_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_ports_from_vlan", 33) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_ports_from_vlan", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_ports_from_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_ports_from_vlan (iface, vlan_id, thrift_port_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_ports_from_vlan (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_get_vlan_stats (switch_sai_rpcIf * iface, const gint16 vlan_id, const GArray * counter_ids, const gint32 number_of_counters, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_get_vlan_stats", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_get_vlan_stats_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, vlan_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "counter_ids", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i68;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) counter_ids->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i68 = 0; i68 < counter_ids->len; i68++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (counter_ids, gint32, i68)), error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "number_of_counters", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, number_of_counters, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_get_vlan_stats (switch_sai_rpcIf * iface, GArray ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_get_vlan_stats", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_get_vlan_stats", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint64* _elem69 = g_new (gint64, 1);
                if ((ret = thrift_protocol_read_i64 (protocol, &*_elem69, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem69, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_get_vlan_stats (switch_sai_rpcIf * iface, GArray ** _return, const gint16 vlan_id, const GArray * counter_ids, const gint32 number_of_counters, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_get_vlan_stats (iface, vlan_id, counter_ids, number_of_counters, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_get_vlan_stats (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_virtual_router (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_virtual_router", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_virtual_router_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i70;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i70 = 0; i70 < thrift_attr_list->len; i70++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i70))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_virtual_router (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_virtual_router", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_virtual_router", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_virtual_router (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_virtual_router (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_virtual_router (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_virtual_router (switch_sai_rpcIf * iface, const sai_thrift_object_id_t vr_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_virtual_router", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_virtual_router_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "vr_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, vr_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_virtual_router (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_virtual_router", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_virtual_router", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_virtual_router (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t vr_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_virtual_router (iface, vr_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_virtual_router (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_route (switch_sai_rpcIf * iface, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_route", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_route_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_unicast_route_entry", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_unicast_route_entry), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i71;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i71 = 0; i71 < thrift_attr_list->len; i71++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i71))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_route (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_route", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_route", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_route (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_route (iface, thrift_unicast_route_entry, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_route (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_route (switch_sai_rpcIf * iface, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_route", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_route_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_unicast_route_entry", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_unicast_route_entry), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_route (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_route", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_route", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_route (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_route (iface, thrift_unicast_route_entry, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_route (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_router_interface (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_router_interface", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_router_interface_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i72;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i72 = 0; i72 < thrift_attr_list->len; i72++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i72))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_router_interface (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_router_interface", 34) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_router_interface", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_router_interface (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_router_interface (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_router_interface (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_router_interface (switch_sai_rpcIf * iface, const sai_thrift_object_id_t rif_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_router_interface", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_router_interface_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "rif_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, rif_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_router_interface (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_router_interface", 34) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_router_interface", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_router_interface (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t rif_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_router_interface (iface, rif_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_router_interface (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_next_hop (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_next_hop", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_next_hop_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i73;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i73 = 0; i73 < thrift_attr_list->len; i73++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i73))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_next_hop (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_next_hop", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_next_hop", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_next_hop (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_next_hop (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_next_hop (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_next_hop (switch_sai_rpcIf * iface, const sai_thrift_object_id_t next_hop_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_next_hop", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_next_hop_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, next_hop_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_next_hop (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_next_hop", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_next_hop", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_next_hop (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_next_hop (iface, next_hop_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_next_hop (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_next_hop_group (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_next_hop_group", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_next_hop_group_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i74;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i74 = 0; i74 < thrift_attr_list->len; i74++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i74))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_next_hop_group (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_next_hop_group", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_next_hop_group", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_next_hop_group (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_next_hop_group (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_next_hop_group (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_next_hop_group (switch_sai_rpcIf * iface, const sai_thrift_object_id_t next_hop_group_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_next_hop_group", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_next_hop_group_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_group_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, next_hop_group_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_next_hop_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_next_hop_group", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_next_hop_group", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_next_hop_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_next_hop_group (iface, next_hop_group_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_next_hop_group (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_add_next_hop_to_group (switch_sai_rpcIf * iface, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_add_next_hop_to_group", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_add_next_hop_to_group_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_group_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, next_hop_group_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_nexthops", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i75;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) thrift_nexthops->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i75 = 0; i75 < thrift_nexthops->len; i75++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (thrift_nexthops, gint64, i75)), error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_add_next_hop_to_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_add_next_hop_to_group", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_add_next_hop_to_group", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_add_next_hop_to_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_add_next_hop_to_group (iface, next_hop_group_id, thrift_nexthops, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_add_next_hop_to_group (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_next_hop_from_group (switch_sai_rpcIf * iface, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_next_hop_from_group", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_next_hop_from_group_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_group_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, next_hop_group_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_nexthops", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i76;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) thrift_nexthops->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i76 = 0; i76 < thrift_nexthops->len; i76++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (thrift_nexthops, gint64, i76)), error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_next_hop_from_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_next_hop_from_group", 37) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_next_hop_from_group", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_next_hop_from_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_next_hop_from_group (iface, next_hop_group_id, thrift_nexthops, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_next_hop_from_group (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_lag (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_lag", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_lag_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i77;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i77 = 0; i77 < thrift_attr_list->len; i77++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i77))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_lag (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_lag", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_lag", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_lag (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_lag (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_lag (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_lag (switch_sai_rpcIf * iface, const sai_thrift_object_id_t lag_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_lag", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_lag_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "lag_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, lag_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_lag (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_lag", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_lag", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_lag (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t lag_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_lag (iface, lag_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_lag (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_lag_member (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_lag_member", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_lag_member_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i78;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i78 = 0; i78 < thrift_attr_list->len; i78++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i78))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_lag_member (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_lag_member", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_lag_member", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_lag_member (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_lag_member (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_lag_member (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_lag_member (switch_sai_rpcIf * iface, const sai_thrift_object_id_t lag_member_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_lag_member", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_lag_member_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "lag_member_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, lag_member_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_lag_member (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_lag_member", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_lag_member", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_lag_member (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t lag_member_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_lag_member (iface, lag_member_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_lag_member (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_stp_entry (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_stp_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_stp_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i79;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i79 = 0; i79 < thrift_attr_list->len; i79++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i79))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_stp_entry (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_stp_entry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_stp_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_stp_entry (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_stp_entry (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_stp_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_stp_entry (switch_sai_rpcIf * iface, const sai_thrift_object_id_t stp_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_stp_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_stp_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "stp_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, stp_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_stp_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_stp_entry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_stp_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_stp_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t stp_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_stp_entry (iface, stp_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_stp_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_set_stp_port_state (switch_sai_rpcIf * iface, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_set_stp_port_state", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_set_stp_port_state_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "stp_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, stp_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "port_id", T_I64, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, port_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "stp_port_state", T_BYTE, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, stp_port_state, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_set_stp_port_state (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_set_stp_port_state", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_set_stp_port_state", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_set_stp_port_state (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_set_stp_port_state (iface, stp_id, port_id, stp_port_state, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_set_stp_port_state (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_get_stp_port_state (switch_sai_rpcIf * iface, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_get_stp_port_state", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_get_stp_port_state_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "stp_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, stp_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "port_id", T_I64, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, port_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_get_stp_port_state (switch_sai_rpcIf * iface, sai_thrift_port_stp_port_state_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_get_stp_port_state", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_get_stp_port_state", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BYTE)
          {
            if ((ret = thrift_protocol_read_byte (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_get_stp_port_state (switch_sai_rpcIf * iface, sai_thrift_port_stp_port_state_t* _return, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_get_stp_port_state (iface, stp_id, port_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_get_stp_port_state (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_neighbor_entry (switch_sai_rpcIf * iface, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_neighbor_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_neighbor_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_neighbor_entry", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_neighbor_entry), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i80;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i80 = 0; i80 < thrift_attr_list->len; i80++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i80))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_neighbor_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_neighbor_entry", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_neighbor_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_neighbor_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_neighbor_entry (iface, thrift_neighbor_entry, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_neighbor_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_neighbor_entry (switch_sai_rpcIf * iface, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_neighbor_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_neighbor_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_neighbor_entry", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_neighbor_entry), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_neighbor_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_neighbor_entry", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_neighbor_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_neighbor_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_neighbor_entry (iface, thrift_neighbor_entry, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_neighbor_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_get_switch_attribute (switch_sai_rpcIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_get_switch_attribute", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_get_switch_attribute_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_get_switch_attribute (switch_sai_rpcIf * iface, sai_thrift_attribute_list_t ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_get_switch_attribute", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_get_switch_attribute", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_get_switch_attribute (switch_sai_rpcIf * iface, sai_thrift_attribute_list_t ** _return, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_get_switch_attribute (iface, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_get_switch_attribute (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_set_switch_attribute (switch_sai_rpcIf * iface, const sai_thrift_attribute_t * attribute, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_set_switch_attribute", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_set_switch_attribute_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "attribute", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (attribute), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_set_switch_attribute (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_set_switch_attribute", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_set_switch_attribute", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_set_switch_attribute (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_attribute_t * attribute, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_set_switch_attribute (iface, attribute, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_set_switch_attribute (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_hostif (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_hostif", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_hostif_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i81;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i81 = 0; i81 < thrift_attr_list->len; i81++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i81))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_hostif (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_hostif", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_hostif", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_hostif (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_hostif (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_hostif (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_hostif (switch_sai_rpcIf * iface, const sai_thrift_object_id_t hif_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_hostif", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_hostif_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "hif_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, hif_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_hostif (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_hostif", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_hostif", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_hostif (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t hif_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_hostif (iface, hif_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_hostif (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_hostif_trap_group (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_hostif_trap_group", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_hostif_trap_group_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i82;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i82 = 0; i82 < thrift_attr_list->len; i82++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i82))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_hostif_trap_group (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_hostif_trap_group", 35) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_hostif_trap_group", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_hostif_trap_group (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_hostif_trap_group (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_hostif_trap_group (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_hostif_trap_group (switch_sai_rpcIf * iface, const sai_thrift_object_id_t trap_group_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_hostif_trap_group", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_hostif_trap_group_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "trap_group_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, trap_group_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_hostif_trap_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_hostif_trap_group", 35) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_hostif_trap_group", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_hostif_trap_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t trap_group_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_hostif_trap_group (iface, trap_group_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_hostif_trap_group (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_hostif_trap (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_hostif_trap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_hostif_trap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i83;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i83 = 0; i83 < thrift_attr_list->len; i83++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i83))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_hostif_trap", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_hostif_trap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_hostif_trap (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_hostif_trap (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_hostif_trap (switch_sai_rpcIf * iface, const sai_thrift_hostif_trap_id_t trap_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_hostif_trap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_hostif_trap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "trap_id", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, trap_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_hostif_trap", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_hostif_trap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_hostif_trap_id_t trap_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_hostif_trap (iface, trap_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_hostif_trap (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_set_hostif_trap (switch_sai_rpcIf * iface, const sai_thrift_hostif_trap_id_t trap_id, const sai_thrift_attribute_t * thrift_attr, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_set_hostif_trap", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_set_hostif_trap_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "trap_id", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, trap_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (thrift_attr), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_set_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_set_hostif_trap", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_set_hostif_trap", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_set_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_hostif_trap_id_t trap_id, const sai_thrift_attribute_t * thrift_attr, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_set_hostif_trap (iface, trap_id, thrift_attr, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_set_hostif_trap (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_acl_table (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_acl_table", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_acl_table_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i84;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i84 = 0; i84 < thrift_attr_list->len; i84++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i84))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_acl_table (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_acl_table", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_acl_table", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_acl_table (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_acl_table (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_acl_table (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_delete_acl_table (switch_sai_rpcIf * iface, const sai_thrift_object_id_t acl_table_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_delete_acl_table", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_delete_acl_table_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "acl_table_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, acl_table_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_delete_acl_table (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_delete_acl_table", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_delete_acl_table", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_delete_acl_table (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_table_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_delete_acl_table (iface, acl_table_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_delete_acl_table (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_acl_entry (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_acl_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_acl_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i85;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i85 = 0; i85 < thrift_attr_list->len; i85++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i85))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_acl_entry (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_acl_entry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_acl_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_acl_entry (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_acl_entry (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_acl_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_delete_acl_entry (switch_sai_rpcIf * iface, const sai_thrift_object_id_t acl_entry, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_delete_acl_entry", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_delete_acl_entry_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "acl_entry", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, acl_entry, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_delete_acl_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_delete_acl_entry", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_delete_acl_entry", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_delete_acl_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_entry, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_delete_acl_entry (iface, acl_entry, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_delete_acl_entry (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_acl_counter (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_acl_counter", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_acl_counter_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i86;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i86 = 0; i86 < thrift_attr_list->len; i86++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i86))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_acl_counter (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_acl_counter", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_acl_counter", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_acl_counter (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_acl_counter (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_acl_counter (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_delete_acl_counter (switch_sai_rpcIf * iface, const sai_thrift_object_id_t acl_counter_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_delete_acl_counter", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_delete_acl_counter_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "acl_counter_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, acl_counter_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_delete_acl_counter (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_delete_acl_counter", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_delete_acl_counter", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_delete_acl_counter (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_counter_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_delete_acl_counter (iface, acl_counter_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_delete_acl_counter (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_get_acl_counter_attribute (switch_sai_rpcIf * iface, const sai_thrift_object_id_t acl_counter_id, const GArray * thrift_attr_ids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_get_acl_counter_attribute", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_get_acl_counter_attribute_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "acl_counter_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, acl_counter_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_ids", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i87;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) thrift_attr_ids->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i87 = 0; i87 < thrift_attr_ids->len; i87++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (thrift_attr_ids, gint32, i87)), error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_get_acl_counter_attribute (switch_sai_rpcIf * iface, GPtrArray ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_get_acl_counter_attribute", 36) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_get_acl_counter_attribute", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                sai_thrift_attribute_value_t * _elem88 = NULL;
                if ( _elem88 != NULL)
                {
                  g_object_unref (_elem88);
                }
                _elem88 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_VALUE_T, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem88), protocol, error)) < 0)
                {
                  g_object_unref (_elem88);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem88);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_get_acl_counter_attribute (switch_sai_rpcIf * iface, GPtrArray ** _return, const sai_thrift_object_id_t acl_counter_id, const GArray * thrift_attr_ids, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_get_acl_counter_attribute (iface, acl_counter_id, thrift_attr_ids, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_get_acl_counter_attribute (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_mirror_session (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_mirror_session", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_mirror_session_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i89;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i89 = 0; i89 < thrift_attr_list->len; i89++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i89))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_mirror_session (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_mirror_session", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_mirror_session", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_mirror_session (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_mirror_session (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_mirror_session (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_mirror_session (switch_sai_rpcIf * iface, const sai_thrift_object_id_t session_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_mirror_session", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_mirror_session_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "session_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, session_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_mirror_session (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_mirror_session", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_mirror_session", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_mirror_session (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t session_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_mirror_session (iface, session_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_mirror_session (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_create_policer (switch_sai_rpcIf * iface, const GPtrArray * thrift_attr_list, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_create_policer", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_create_policer_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i90;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) thrift_attr_list->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i90 = 0; i90 < thrift_attr_list->len; i90++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) thrift_attr_list, i90))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_create_policer (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_create_policer", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_create_policer", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I64)
          {
            if ((ret = thrift_protocol_read_i64 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_create_policer (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_create_policer (iface, thrift_attr_list, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_create_policer (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_remove_policer (switch_sai_rpcIf * iface, const sai_thrift_object_id_t policer_id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_remove_policer", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_remove_policer_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "policer_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, policer_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_remove_policer (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_remove_policer", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_remove_policer", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_remove_policer (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t policer_id, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_remove_policer (iface, policer_id, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_remove_policer (iface, _return, error))
    return FALSE;
  return TRUE;
}

gboolean switch_sai_rpc_client_send_sai_thrift_get_policer_stats (switch_sai_rpcIf * iface, const sai_thrift_object_id_t policer_id, const GArray * counter_ids, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sai_thrift_get_policer_stats", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_get_policer_stats_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "policer_id", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, policer_id, error)) < 0)
      return 0;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "counter_ids", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i91;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) counter_ids->len, error)) < 0)
        return 0;
      xfer += ret;
      for (i91 = 0; i91 < counter_ids->len; i91++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (counter_ids, gint32, i91)), error)) < 0)
          return 0;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_recv_sai_thrift_get_policer_stats (switch_sai_rpcIf * iface, GArray ** _return, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = SWITCH_SAI_RPC_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sai_thrift_get_policer_stats", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sai_thrift_get_policer_stats", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint64* _elem92 = g_new (gint64, 1);
                if ((ret = thrift_protocol_read_i64 (protocol, &*_elem92, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem92, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean switch_sai_rpc_client_sai_thrift_get_policer_stats (switch_sai_rpcIf * iface, GArray ** _return, const sai_thrift_object_id_t policer_id, const GArray * counter_ids, GError ** error)
{
  if (!switch_sai_rpc_client_send_sai_thrift_get_policer_stats (iface, policer_id, counter_ids, error))
    return FALSE;
  if (!switch_sai_rpc_client_recv_sai_thrift_get_policer_stats (iface, _return, error))
    return FALSE;
  return TRUE;
}

static void
switch_sai_rpc_if_interface_init (switch_sai_rpcIfInterface *iface)
{
  iface->sai_thrift_set_port_attribute = switch_sai_rpc_client_sai_thrift_set_port_attribute;
  iface->sai_thrift_create_fdb_entry = switch_sai_rpc_client_sai_thrift_create_fdb_entry;
  iface->sai_thrift_delete_fdb_entry = switch_sai_rpc_client_sai_thrift_delete_fdb_entry;
  iface->sai_thrift_flush_fdb_entries = switch_sai_rpc_client_sai_thrift_flush_fdb_entries;
  iface->sai_thrift_create_vlan = switch_sai_rpc_client_sai_thrift_create_vlan;
  iface->sai_thrift_delete_vlan = switch_sai_rpc_client_sai_thrift_delete_vlan;
  iface->sai_thrift_add_ports_to_vlan = switch_sai_rpc_client_sai_thrift_add_ports_to_vlan;
  iface->sai_thrift_remove_ports_from_vlan = switch_sai_rpc_client_sai_thrift_remove_ports_from_vlan;
  iface->sai_thrift_get_vlan_stats = switch_sai_rpc_client_sai_thrift_get_vlan_stats;
  iface->sai_thrift_create_virtual_router = switch_sai_rpc_client_sai_thrift_create_virtual_router;
  iface->sai_thrift_remove_virtual_router = switch_sai_rpc_client_sai_thrift_remove_virtual_router;
  iface->sai_thrift_create_route = switch_sai_rpc_client_sai_thrift_create_route;
  iface->sai_thrift_remove_route = switch_sai_rpc_client_sai_thrift_remove_route;
  iface->sai_thrift_create_router_interface = switch_sai_rpc_client_sai_thrift_create_router_interface;
  iface->sai_thrift_remove_router_interface = switch_sai_rpc_client_sai_thrift_remove_router_interface;
  iface->sai_thrift_create_next_hop = switch_sai_rpc_client_sai_thrift_create_next_hop;
  iface->sai_thrift_remove_next_hop = switch_sai_rpc_client_sai_thrift_remove_next_hop;
  iface->sai_thrift_create_next_hop_group = switch_sai_rpc_client_sai_thrift_create_next_hop_group;
  iface->sai_thrift_remove_next_hop_group = switch_sai_rpc_client_sai_thrift_remove_next_hop_group;
  iface->sai_thrift_add_next_hop_to_group = switch_sai_rpc_client_sai_thrift_add_next_hop_to_group;
  iface->sai_thrift_remove_next_hop_from_group = switch_sai_rpc_client_sai_thrift_remove_next_hop_from_group;
  iface->sai_thrift_create_lag = switch_sai_rpc_client_sai_thrift_create_lag;
  iface->sai_thrift_remove_lag = switch_sai_rpc_client_sai_thrift_remove_lag;
  iface->sai_thrift_create_lag_member = switch_sai_rpc_client_sai_thrift_create_lag_member;
  iface->sai_thrift_remove_lag_member = switch_sai_rpc_client_sai_thrift_remove_lag_member;
  iface->sai_thrift_create_stp_entry = switch_sai_rpc_client_sai_thrift_create_stp_entry;
  iface->sai_thrift_remove_stp_entry = switch_sai_rpc_client_sai_thrift_remove_stp_entry;
  iface->sai_thrift_set_stp_port_state = switch_sai_rpc_client_sai_thrift_set_stp_port_state;
  iface->sai_thrift_get_stp_port_state = switch_sai_rpc_client_sai_thrift_get_stp_port_state;
  iface->sai_thrift_create_neighbor_entry = switch_sai_rpc_client_sai_thrift_create_neighbor_entry;
  iface->sai_thrift_remove_neighbor_entry = switch_sai_rpc_client_sai_thrift_remove_neighbor_entry;
  iface->sai_thrift_get_switch_attribute = switch_sai_rpc_client_sai_thrift_get_switch_attribute;
  iface->sai_thrift_set_switch_attribute = switch_sai_rpc_client_sai_thrift_set_switch_attribute;
  iface->sai_thrift_create_hostif = switch_sai_rpc_client_sai_thrift_create_hostif;
  iface->sai_thrift_remove_hostif = switch_sai_rpc_client_sai_thrift_remove_hostif;
  iface->sai_thrift_create_hostif_trap_group = switch_sai_rpc_client_sai_thrift_create_hostif_trap_group;
  iface->sai_thrift_remove_hostif_trap_group = switch_sai_rpc_client_sai_thrift_remove_hostif_trap_group;
  iface->sai_thrift_create_hostif_trap = switch_sai_rpc_client_sai_thrift_create_hostif_trap;
  iface->sai_thrift_remove_hostif_trap = switch_sai_rpc_client_sai_thrift_remove_hostif_trap;
  iface->sai_thrift_set_hostif_trap = switch_sai_rpc_client_sai_thrift_set_hostif_trap;
  iface->sai_thrift_create_acl_table = switch_sai_rpc_client_sai_thrift_create_acl_table;
  iface->sai_thrift_delete_acl_table = switch_sai_rpc_client_sai_thrift_delete_acl_table;
  iface->sai_thrift_create_acl_entry = switch_sai_rpc_client_sai_thrift_create_acl_entry;
  iface->sai_thrift_delete_acl_entry = switch_sai_rpc_client_sai_thrift_delete_acl_entry;
  iface->sai_thrift_create_acl_counter = switch_sai_rpc_client_sai_thrift_create_acl_counter;
  iface->sai_thrift_delete_acl_counter = switch_sai_rpc_client_sai_thrift_delete_acl_counter;
  iface->sai_thrift_get_acl_counter_attribute = switch_sai_rpc_client_sai_thrift_get_acl_counter_attribute;
  iface->sai_thrift_create_mirror_session = switch_sai_rpc_client_sai_thrift_create_mirror_session;
  iface->sai_thrift_remove_mirror_session = switch_sai_rpc_client_sai_thrift_remove_mirror_session;
  iface->sai_thrift_create_policer = switch_sai_rpc_client_sai_thrift_create_policer;
  iface->sai_thrift_remove_policer = switch_sai_rpc_client_sai_thrift_remove_policer;
  iface->sai_thrift_get_policer_stats = switch_sai_rpc_client_sai_thrift_get_policer_stats;
}

static void
switch_sai_rpc_client_init (switch_sai_rpcClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
switch_sai_rpc_client_class_init (switch_sai_rpcClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = switch_sai_rpc_client_set_property;
  gobject_class->get_property = switch_sai_rpc_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_SWITCH_SAI_RPC_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_SWITCH_SAI_RPC_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

static void
switch_sai_rpc_handler_switch_sai_rpc_if_interface_init (switch_sai_rpcIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (switch_sai_rpcHandler, 
                         switch_sai_rpc_handler,
                         G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (TYPE_SWITCH_SAI_RPC_IF,
                                                switch_sai_rpc_handler_switch_sai_rpc_if_interface_init))

gboolean switch_sai_rpc_handler_sai_thrift_set_port_attribute (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t port_id, const sai_thrift_attribute_t * thrift_attr, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_set_port_attribute (iface, _return, port_id, thrift_attr, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_fdb_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_fdb_entry_t * thrift_fdb_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_fdb_entry (iface, _return, thrift_fdb_entry, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_delete_fdb_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_fdb_entry_t * thrift_fdb_entry, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_delete_fdb_entry (iface, _return, thrift_fdb_entry, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_flush_fdb_entries (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_flush_fdb_entries (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_vlan (iface, _return, vlan_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_delete_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_delete_vlan (iface, _return, vlan_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_add_ports_to_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_add_ports_to_vlan (iface, _return, vlan_id, thrift_port_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_ports_from_vlan (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const gint16 vlan_id, const GPtrArray * thrift_port_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_ports_from_vlan (iface, _return, vlan_id, thrift_port_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_get_vlan_stats (switch_sai_rpcIf * iface, GArray ** _return, const gint16 vlan_id, const GArray * counter_ids, const gint32 number_of_counters, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_get_vlan_stats (iface, _return, vlan_id, counter_ids, number_of_counters, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_virtual_router (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_virtual_router (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_virtual_router (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t vr_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_virtual_router (iface, _return, vr_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_route (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_route (iface, _return, thrift_unicast_route_entry, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_route (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_route (iface, _return, thrift_unicast_route_entry, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_router_interface (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_router_interface (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_router_interface (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t rif_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_router_interface (iface, _return, rif_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_next_hop (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_next_hop (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_next_hop (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_next_hop (iface, _return, next_hop_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_next_hop_group (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_next_hop_group (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_next_hop_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_next_hop_group (iface, _return, next_hop_group_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_add_next_hop_to_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_add_next_hop_to_group (iface, _return, next_hop_group_id, thrift_nexthops, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_next_hop_from_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t next_hop_group_id, const GArray * thrift_nexthops, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_next_hop_from_group (iface, _return, next_hop_group_id, thrift_nexthops, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_lag (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_lag (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_lag (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t lag_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_lag (iface, _return, lag_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_lag_member (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_lag_member (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_lag_member (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t lag_member_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_lag_member (iface, _return, lag_member_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_stp_entry (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_stp_entry (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_stp_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t stp_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_stp_entry (iface, _return, stp_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_set_stp_port_state (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, const sai_thrift_port_stp_port_state_t stp_port_state, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_set_stp_port_state (iface, _return, stp_id, port_id, stp_port_state, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_get_stp_port_state (switch_sai_rpcIf * iface, sai_thrift_port_stp_port_state_t* _return, const sai_thrift_object_id_t stp_id, const sai_thrift_object_id_t port_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_get_stp_port_state (iface, _return, stp_id, port_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_neighbor_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_neighbor_entry (iface, _return, thrift_neighbor_entry, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_neighbor_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_neighbor_entry_t * thrift_neighbor_entry, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_neighbor_entry (iface, _return, thrift_neighbor_entry, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_get_switch_attribute (switch_sai_rpcIf * iface, sai_thrift_attribute_list_t ** _return, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_get_switch_attribute (iface, _return, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_set_switch_attribute (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_attribute_t * attribute, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_set_switch_attribute (iface, _return, attribute, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_hostif (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_hostif (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_hostif (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t hif_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_hostif (iface, _return, hif_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_hostif_trap_group (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_hostif_trap_group (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_hostif_trap_group (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t trap_group_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_hostif_trap_group (iface, _return, trap_group_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_hostif_trap (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_hostif_trap_id_t trap_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_hostif_trap (iface, _return, trap_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_set_hostif_trap (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_hostif_trap_id_t trap_id, const sai_thrift_attribute_t * thrift_attr, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_set_hostif_trap (iface, _return, trap_id, thrift_attr, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_acl_table (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_acl_table (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_delete_acl_table (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_table_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_delete_acl_table (iface, _return, acl_table_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_acl_entry (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_acl_entry (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_delete_acl_entry (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_entry, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_delete_acl_entry (iface, _return, acl_entry, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_acl_counter (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_acl_counter (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_delete_acl_counter (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t acl_counter_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_delete_acl_counter (iface, _return, acl_counter_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_get_acl_counter_attribute (switch_sai_rpcIf * iface, GPtrArray ** _return, const sai_thrift_object_id_t acl_counter_id, const GArray * thrift_attr_ids, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_get_acl_counter_attribute (iface, _return, acl_counter_id, thrift_attr_ids, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_mirror_session (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_mirror_session (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_mirror_session (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t session_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_mirror_session (iface, _return, session_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_create_policer (switch_sai_rpcIf * iface, sai_thrift_object_id_t* _return, const GPtrArray * thrift_attr_list, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_create_policer (iface, _return, thrift_attr_list, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_remove_policer (switch_sai_rpcIf * iface, sai_thrift_status_t* _return, const sai_thrift_object_id_t policer_id, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_remove_policer (iface, _return, policer_id, error);
}

gboolean switch_sai_rpc_handler_sai_thrift_get_policer_stats (switch_sai_rpcIf * iface, GArray ** _return, const sai_thrift_object_id_t policer_id, const GArray * counter_ids, GError ** error)
{
  g_return_val_if_fail (IS_SWITCH_SAI_RPC_HANDLER (iface), FALSE);

  return SWITCH_SAI_RPC_HANDLER_GET_CLASS (iface)->sai_thrift_get_policer_stats (iface, _return, policer_id, counter_ids, error);
}

static void
switch_sai_rpc_handler_switch_sai_rpc_if_interface_init (switch_sai_rpcIfInterface *iface)
{
  iface->sai_thrift_set_port_attribute = switch_sai_rpc_handler_sai_thrift_set_port_attribute;
  iface->sai_thrift_create_fdb_entry = switch_sai_rpc_handler_sai_thrift_create_fdb_entry;
  iface->sai_thrift_delete_fdb_entry = switch_sai_rpc_handler_sai_thrift_delete_fdb_entry;
  iface->sai_thrift_flush_fdb_entries = switch_sai_rpc_handler_sai_thrift_flush_fdb_entries;
  iface->sai_thrift_create_vlan = switch_sai_rpc_handler_sai_thrift_create_vlan;
  iface->sai_thrift_delete_vlan = switch_sai_rpc_handler_sai_thrift_delete_vlan;
  iface->sai_thrift_add_ports_to_vlan = switch_sai_rpc_handler_sai_thrift_add_ports_to_vlan;
  iface->sai_thrift_remove_ports_from_vlan = switch_sai_rpc_handler_sai_thrift_remove_ports_from_vlan;
  iface->sai_thrift_get_vlan_stats = switch_sai_rpc_handler_sai_thrift_get_vlan_stats;
  iface->sai_thrift_create_virtual_router = switch_sai_rpc_handler_sai_thrift_create_virtual_router;
  iface->sai_thrift_remove_virtual_router = switch_sai_rpc_handler_sai_thrift_remove_virtual_router;
  iface->sai_thrift_create_route = switch_sai_rpc_handler_sai_thrift_create_route;
  iface->sai_thrift_remove_route = switch_sai_rpc_handler_sai_thrift_remove_route;
  iface->sai_thrift_create_router_interface = switch_sai_rpc_handler_sai_thrift_create_router_interface;
  iface->sai_thrift_remove_router_interface = switch_sai_rpc_handler_sai_thrift_remove_router_interface;
  iface->sai_thrift_create_next_hop = switch_sai_rpc_handler_sai_thrift_create_next_hop;
  iface->sai_thrift_remove_next_hop = switch_sai_rpc_handler_sai_thrift_remove_next_hop;
  iface->sai_thrift_create_next_hop_group = switch_sai_rpc_handler_sai_thrift_create_next_hop_group;
  iface->sai_thrift_remove_next_hop_group = switch_sai_rpc_handler_sai_thrift_remove_next_hop_group;
  iface->sai_thrift_add_next_hop_to_group = switch_sai_rpc_handler_sai_thrift_add_next_hop_to_group;
  iface->sai_thrift_remove_next_hop_from_group = switch_sai_rpc_handler_sai_thrift_remove_next_hop_from_group;
  iface->sai_thrift_create_lag = switch_sai_rpc_handler_sai_thrift_create_lag;
  iface->sai_thrift_remove_lag = switch_sai_rpc_handler_sai_thrift_remove_lag;
  iface->sai_thrift_create_lag_member = switch_sai_rpc_handler_sai_thrift_create_lag_member;
  iface->sai_thrift_remove_lag_member = switch_sai_rpc_handler_sai_thrift_remove_lag_member;
  iface->sai_thrift_create_stp_entry = switch_sai_rpc_handler_sai_thrift_create_stp_entry;
  iface->sai_thrift_remove_stp_entry = switch_sai_rpc_handler_sai_thrift_remove_stp_entry;
  iface->sai_thrift_set_stp_port_state = switch_sai_rpc_handler_sai_thrift_set_stp_port_state;
  iface->sai_thrift_get_stp_port_state = switch_sai_rpc_handler_sai_thrift_get_stp_port_state;
  iface->sai_thrift_create_neighbor_entry = switch_sai_rpc_handler_sai_thrift_create_neighbor_entry;
  iface->sai_thrift_remove_neighbor_entry = switch_sai_rpc_handler_sai_thrift_remove_neighbor_entry;
  iface->sai_thrift_get_switch_attribute = switch_sai_rpc_handler_sai_thrift_get_switch_attribute;
  iface->sai_thrift_set_switch_attribute = switch_sai_rpc_handler_sai_thrift_set_switch_attribute;
  iface->sai_thrift_create_hostif = switch_sai_rpc_handler_sai_thrift_create_hostif;
  iface->sai_thrift_remove_hostif = switch_sai_rpc_handler_sai_thrift_remove_hostif;
  iface->sai_thrift_create_hostif_trap_group = switch_sai_rpc_handler_sai_thrift_create_hostif_trap_group;
  iface->sai_thrift_remove_hostif_trap_group = switch_sai_rpc_handler_sai_thrift_remove_hostif_trap_group;
  iface->sai_thrift_create_hostif_trap = switch_sai_rpc_handler_sai_thrift_create_hostif_trap;
  iface->sai_thrift_remove_hostif_trap = switch_sai_rpc_handler_sai_thrift_remove_hostif_trap;
  iface->sai_thrift_set_hostif_trap = switch_sai_rpc_handler_sai_thrift_set_hostif_trap;
  iface->sai_thrift_create_acl_table = switch_sai_rpc_handler_sai_thrift_create_acl_table;
  iface->sai_thrift_delete_acl_table = switch_sai_rpc_handler_sai_thrift_delete_acl_table;
  iface->sai_thrift_create_acl_entry = switch_sai_rpc_handler_sai_thrift_create_acl_entry;
  iface->sai_thrift_delete_acl_entry = switch_sai_rpc_handler_sai_thrift_delete_acl_entry;
  iface->sai_thrift_create_acl_counter = switch_sai_rpc_handler_sai_thrift_create_acl_counter;
  iface->sai_thrift_delete_acl_counter = switch_sai_rpc_handler_sai_thrift_delete_acl_counter;
  iface->sai_thrift_get_acl_counter_attribute = switch_sai_rpc_handler_sai_thrift_get_acl_counter_attribute;
  iface->sai_thrift_create_mirror_session = switch_sai_rpc_handler_sai_thrift_create_mirror_session;
  iface->sai_thrift_remove_mirror_session = switch_sai_rpc_handler_sai_thrift_remove_mirror_session;
  iface->sai_thrift_create_policer = switch_sai_rpc_handler_sai_thrift_create_policer;
  iface->sai_thrift_remove_policer = switch_sai_rpc_handler_sai_thrift_remove_policer;
  iface->sai_thrift_get_policer_stats = switch_sai_rpc_handler_sai_thrift_get_policer_stats;
}

static void
switch_sai_rpc_handler_init (switch_sai_rpcHandler *self)
{
  THRIFT_UNUSED_VAR (self);
}

static void
switch_sai_rpc_handler_class_init (switch_sai_rpcHandlerClass *cls)
{
  cls->sai_thrift_set_port_attribute = NULL;
  cls->sai_thrift_create_fdb_entry = NULL;
  cls->sai_thrift_delete_fdb_entry = NULL;
  cls->sai_thrift_flush_fdb_entries = NULL;
  cls->sai_thrift_create_vlan = NULL;
  cls->sai_thrift_delete_vlan = NULL;
  cls->sai_thrift_add_ports_to_vlan = NULL;
  cls->sai_thrift_remove_ports_from_vlan = NULL;
  cls->sai_thrift_get_vlan_stats = NULL;
  cls->sai_thrift_create_virtual_router = NULL;
  cls->sai_thrift_remove_virtual_router = NULL;
  cls->sai_thrift_create_route = NULL;
  cls->sai_thrift_remove_route = NULL;
  cls->sai_thrift_create_router_interface = NULL;
  cls->sai_thrift_remove_router_interface = NULL;
  cls->sai_thrift_create_next_hop = NULL;
  cls->sai_thrift_remove_next_hop = NULL;
  cls->sai_thrift_create_next_hop_group = NULL;
  cls->sai_thrift_remove_next_hop_group = NULL;
  cls->sai_thrift_add_next_hop_to_group = NULL;
  cls->sai_thrift_remove_next_hop_from_group = NULL;
  cls->sai_thrift_create_lag = NULL;
  cls->sai_thrift_remove_lag = NULL;
  cls->sai_thrift_create_lag_member = NULL;
  cls->sai_thrift_remove_lag_member = NULL;
  cls->sai_thrift_create_stp_entry = NULL;
  cls->sai_thrift_remove_stp_entry = NULL;
  cls->sai_thrift_set_stp_port_state = NULL;
  cls->sai_thrift_get_stp_port_state = NULL;
  cls->sai_thrift_create_neighbor_entry = NULL;
  cls->sai_thrift_remove_neighbor_entry = NULL;
  cls->sai_thrift_get_switch_attribute = NULL;
  cls->sai_thrift_set_switch_attribute = NULL;
  cls->sai_thrift_create_hostif = NULL;
  cls->sai_thrift_remove_hostif = NULL;
  cls->sai_thrift_create_hostif_trap_group = NULL;
  cls->sai_thrift_remove_hostif_trap_group = NULL;
  cls->sai_thrift_create_hostif_trap = NULL;
  cls->sai_thrift_remove_hostif_trap = NULL;
  cls->sai_thrift_set_hostif_trap = NULL;
  cls->sai_thrift_create_acl_table = NULL;
  cls->sai_thrift_delete_acl_table = NULL;
  cls->sai_thrift_create_acl_entry = NULL;
  cls->sai_thrift_delete_acl_entry = NULL;
  cls->sai_thrift_create_acl_counter = NULL;
  cls->sai_thrift_delete_acl_counter = NULL;
  cls->sai_thrift_get_acl_counter_attribute = NULL;
  cls->sai_thrift_create_mirror_session = NULL;
  cls->sai_thrift_remove_mirror_session = NULL;
  cls->sai_thrift_create_policer = NULL;
  cls->sai_thrift_remove_policer = NULL;
  cls->sai_thrift_get_policer_stats = NULL;
}

enum _switch_sai_rpcProcessorProperties
{
  PROP_SWITCH_SAI_RPC_PROCESSOR_0,
  PROP_SWITCH_SAI_RPC_PROCESSOR_HANDLER
};

G_DEFINE_TYPE (switch_sai_rpcProcessor,
               switch_sai_rpc_processor,
               THRIFT_TYPE_DISPATCH_PROCESSOR)

typedef gboolean (* switch_sai_rpcProcessorProcessFunction) (switch_sai_rpcProcessor *, 
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);

typedef struct
{
  gchar *name;
  switch_sai_rpcProcessorProcessFunction function;
} switch_sai_rpc_processor_process_function_def;

static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_port_attribute (switch_sai_rpcProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_fdb_entry (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_fdb_entry (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_flush_fdb_entries (switch_sai_rpcProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_vlan (switch_sai_rpcProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_vlan (switch_sai_rpcProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_add_ports_to_vlan (switch_sai_rpcProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_ports_from_vlan (switch_sai_rpcProcessor *,
                                                                    gint32,
                                                                    ThriftProtocol *,
                                                                    ThriftProtocol *,
                                                                    GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_vlan_stats (switch_sai_rpcProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_virtual_router (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_virtual_router (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_route (switch_sai_rpcProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_route (switch_sai_rpcProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_router_interface (switch_sai_rpcProcessor *,
                                                                     gint32,
                                                                     ThriftProtocol *,
                                                                     ThriftProtocol *,
                                                                     GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_router_interface (switch_sai_rpcProcessor *,
                                                                     gint32,
                                                                     ThriftProtocol *,
                                                                     ThriftProtocol *,
                                                                     GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_next_hop (switch_sai_rpcProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_next_hop (switch_sai_rpcProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_next_hop_group (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_next_hop_group (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_add_next_hop_to_group (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_next_hop_from_group (switch_sai_rpcProcessor *,
                                                                        gint32,
                                                                        ThriftProtocol *,
                                                                        ThriftProtocol *,
                                                                        GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_lag (switch_sai_rpcProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_lag (switch_sai_rpcProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_lag_member (switch_sai_rpcProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_lag_member (switch_sai_rpcProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_stp_entry (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_stp_entry (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_stp_port_state (switch_sai_rpcProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_stp_port_state (switch_sai_rpcProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_neighbor_entry (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_neighbor_entry (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_switch_attribute (switch_sai_rpcProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_switch_attribute (switch_sai_rpcProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_hostif (switch_sai_rpcProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_hostif (switch_sai_rpcProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_hostif_trap_group (switch_sai_rpcProcessor *,
                                                                      gint32,
                                                                      ThriftProtocol *,
                                                                      ThriftProtocol *,
                                                                      GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_hostif_trap_group (switch_sai_rpcProcessor *,
                                                                      gint32,
                                                                      ThriftProtocol *,
                                                                      ThriftProtocol *,
                                                                      GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_hostif_trap (switch_sai_rpcProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_hostif_trap (switch_sai_rpcProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_hostif_trap (switch_sai_rpcProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_acl_table (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_acl_table (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_acl_entry (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_acl_entry (switch_sai_rpcProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_acl_counter (switch_sai_rpcProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_acl_counter (switch_sai_rpcProcessor *,
                                                                gint32,
                                                                ThriftProtocol *,
                                                                ThriftProtocol *,
                                                                GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_acl_counter_attribute (switch_sai_rpcProcessor *,
                                                                       gint32,
                                                                       ThriftProtocol *,
                                                                       ThriftProtocol *,
                                                                       GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_mirror_session (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_mirror_session (switch_sai_rpcProcessor *,
                                                                   gint32,
                                                                   ThriftProtocol *,
                                                                   ThriftProtocol *,
                                                                   GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_policer (switch_sai_rpcProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_policer (switch_sai_rpcProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_policer_stats (switch_sai_rpcProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);

static switch_sai_rpc_processor_process_function_def
switch_sai_rpc_processor_process_function_defs[52] = {
  {
    "sai_thrift_set_port_attribute",
    switch_sai_rpc_processor_process_sai_thrift_set_port_attribute
  },
  {
    "sai_thrift_create_fdb_entry",
    switch_sai_rpc_processor_process_sai_thrift_create_fdb_entry
  },
  {
    "sai_thrift_delete_fdb_entry",
    switch_sai_rpc_processor_process_sai_thrift_delete_fdb_entry
  },
  {
    "sai_thrift_flush_fdb_entries",
    switch_sai_rpc_processor_process_sai_thrift_flush_fdb_entries
  },
  {
    "sai_thrift_create_vlan",
    switch_sai_rpc_processor_process_sai_thrift_create_vlan
  },
  {
    "sai_thrift_delete_vlan",
    switch_sai_rpc_processor_process_sai_thrift_delete_vlan
  },
  {
    "sai_thrift_add_ports_to_vlan",
    switch_sai_rpc_processor_process_sai_thrift_add_ports_to_vlan
  },
  {
    "sai_thrift_remove_ports_from_vlan",
    switch_sai_rpc_processor_process_sai_thrift_remove_ports_from_vlan
  },
  {
    "sai_thrift_get_vlan_stats",
    switch_sai_rpc_processor_process_sai_thrift_get_vlan_stats
  },
  {
    "sai_thrift_create_virtual_router",
    switch_sai_rpc_processor_process_sai_thrift_create_virtual_router
  },
  {
    "sai_thrift_remove_virtual_router",
    switch_sai_rpc_processor_process_sai_thrift_remove_virtual_router
  },
  {
    "sai_thrift_create_route",
    switch_sai_rpc_processor_process_sai_thrift_create_route
  },
  {
    "sai_thrift_remove_route",
    switch_sai_rpc_processor_process_sai_thrift_remove_route
  },
  {
    "sai_thrift_create_router_interface",
    switch_sai_rpc_processor_process_sai_thrift_create_router_interface
  },
  {
    "sai_thrift_remove_router_interface",
    switch_sai_rpc_processor_process_sai_thrift_remove_router_interface
  },
  {
    "sai_thrift_create_next_hop",
    switch_sai_rpc_processor_process_sai_thrift_create_next_hop
  },
  {
    "sai_thrift_remove_next_hop",
    switch_sai_rpc_processor_process_sai_thrift_remove_next_hop
  },
  {
    "sai_thrift_create_next_hop_group",
    switch_sai_rpc_processor_process_sai_thrift_create_next_hop_group
  },
  {
    "sai_thrift_remove_next_hop_group",
    switch_sai_rpc_processor_process_sai_thrift_remove_next_hop_group
  },
  {
    "sai_thrift_add_next_hop_to_group",
    switch_sai_rpc_processor_process_sai_thrift_add_next_hop_to_group
  },
  {
    "sai_thrift_remove_next_hop_from_group",
    switch_sai_rpc_processor_process_sai_thrift_remove_next_hop_from_group
  },
  {
    "sai_thrift_create_lag",
    switch_sai_rpc_processor_process_sai_thrift_create_lag
  },
  {
    "sai_thrift_remove_lag",
    switch_sai_rpc_processor_process_sai_thrift_remove_lag
  },
  {
    "sai_thrift_create_lag_member",
    switch_sai_rpc_processor_process_sai_thrift_create_lag_member
  },
  {
    "sai_thrift_remove_lag_member",
    switch_sai_rpc_processor_process_sai_thrift_remove_lag_member
  },
  {
    "sai_thrift_create_stp_entry",
    switch_sai_rpc_processor_process_sai_thrift_create_stp_entry
  },
  {
    "sai_thrift_remove_stp_entry",
    switch_sai_rpc_processor_process_sai_thrift_remove_stp_entry
  },
  {
    "sai_thrift_set_stp_port_state",
    switch_sai_rpc_processor_process_sai_thrift_set_stp_port_state
  },
  {
    "sai_thrift_get_stp_port_state",
    switch_sai_rpc_processor_process_sai_thrift_get_stp_port_state
  },
  {
    "sai_thrift_create_neighbor_entry",
    switch_sai_rpc_processor_process_sai_thrift_create_neighbor_entry
  },
  {
    "sai_thrift_remove_neighbor_entry",
    switch_sai_rpc_processor_process_sai_thrift_remove_neighbor_entry
  },
  {
    "sai_thrift_get_switch_attribute",
    switch_sai_rpc_processor_process_sai_thrift_get_switch_attribute
  },
  {
    "sai_thrift_set_switch_attribute",
    switch_sai_rpc_processor_process_sai_thrift_set_switch_attribute
  },
  {
    "sai_thrift_create_hostif",
    switch_sai_rpc_processor_process_sai_thrift_create_hostif
  },
  {
    "sai_thrift_remove_hostif",
    switch_sai_rpc_processor_process_sai_thrift_remove_hostif
  },
  {
    "sai_thrift_create_hostif_trap_group",
    switch_sai_rpc_processor_process_sai_thrift_create_hostif_trap_group
  },
  {
    "sai_thrift_remove_hostif_trap_group",
    switch_sai_rpc_processor_process_sai_thrift_remove_hostif_trap_group
  },
  {
    "sai_thrift_create_hostif_trap",
    switch_sai_rpc_processor_process_sai_thrift_create_hostif_trap
  },
  {
    "sai_thrift_remove_hostif_trap",
    switch_sai_rpc_processor_process_sai_thrift_remove_hostif_trap
  },
  {
    "sai_thrift_set_hostif_trap",
    switch_sai_rpc_processor_process_sai_thrift_set_hostif_trap
  },
  {
    "sai_thrift_create_acl_table",
    switch_sai_rpc_processor_process_sai_thrift_create_acl_table
  },
  {
    "sai_thrift_delete_acl_table",
    switch_sai_rpc_processor_process_sai_thrift_delete_acl_table
  },
  {
    "sai_thrift_create_acl_entry",
    switch_sai_rpc_processor_process_sai_thrift_create_acl_entry
  },
  {
    "sai_thrift_delete_acl_entry",
    switch_sai_rpc_processor_process_sai_thrift_delete_acl_entry
  },
  {
    "sai_thrift_create_acl_counter",
    switch_sai_rpc_processor_process_sai_thrift_create_acl_counter
  },
  {
    "sai_thrift_delete_acl_counter",
    switch_sai_rpc_processor_process_sai_thrift_delete_acl_counter
  },
  {
    "sai_thrift_get_acl_counter_attribute",
    switch_sai_rpc_processor_process_sai_thrift_get_acl_counter_attribute
  },
  {
    "sai_thrift_create_mirror_session",
    switch_sai_rpc_processor_process_sai_thrift_create_mirror_session
  },
  {
    "sai_thrift_remove_mirror_session",
    switch_sai_rpc_processor_process_sai_thrift_remove_mirror_session
  },
  {
    "sai_thrift_create_policer",
    switch_sai_rpc_processor_process_sai_thrift_create_policer
  },
  {
    "sai_thrift_remove_policer",
    switch_sai_rpc_processor_process_sai_thrift_remove_policer
  },
  {
    "sai_thrift_get_policer_stats",
    switch_sai_rpc_processor_process_sai_thrift_get_policer_stats
  }
};

static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_port_attribute (switch_sai_rpcProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftSetPortAttributeArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t port_id;
    sai_thrift_attribute_t * thrift_attr;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftSetPortAttributeResult * result_struct;

    g_object_get (args,
                  "port_id", &port_id,
                  "thrift_attr", &thrift_attr,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_set_port_attribute (SWITCH_SAI_RPC_IF (self->handler),
                                                              &return_value,
                                                              port_id,
                                                              thrift_attr,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_port_attribute",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_set_port_attribute implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_port_attribute",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr != NULL)
      g_object_unref (thrift_attr);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_fdb_entry (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateFdbEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_fdb_entry_t * thrift_fdb_entry;
    GPtrArray * thrift_attr_list;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftCreateFdbEntryResult * result_struct;

    g_object_get (args,
                  "thrift_fdb_entry", &thrift_fdb_entry,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_fdb_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            thrift_fdb_entry,
                                                            thrift_attr_list,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_fdb_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_fdb_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_fdb_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_fdb_entry != NULL)
      g_object_unref (thrift_fdb_entry);
    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_fdb_entry (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftDeleteFdbEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_fdb_entry_t * thrift_fdb_entry;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftDeleteFdbEntryResult * result_struct;

    g_object_get (args,
                  "thrift_fdb_entry", &thrift_fdb_entry,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_delete_fdb_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            thrift_fdb_entry,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_fdb_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_delete_fdb_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_fdb_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_fdb_entry != NULL)
      g_object_unref (thrift_fdb_entry);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_flush_fdb_entries (switch_sai_rpcProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftFlushFdbEntriesArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftFlushFdbEntriesResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_flush_fdb_entries (SWITCH_SAI_RPC_IF (self->handler),
                                                             &return_value,
                                                             thrift_attr_list,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_flush_fdb_entries",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_flush_fdb_entries implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_flush_fdb_entries",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_vlan (switch_sai_rpcProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateVlanArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint vlan_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftCreateVlanResult * result_struct;

    g_object_get (args,
                  "vlan_id", &vlan_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_vlan (SWITCH_SAI_RPC_IF (self->handler),
                                                       &return_value,
                                                       vlan_id,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_vlan",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_vlan implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_vlan",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_vlan (switch_sai_rpcProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftDeleteVlanArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint vlan_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftDeleteVlanResult * result_struct;

    g_object_get (args,
                  "vlan_id", &vlan_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_delete_vlan (SWITCH_SAI_RPC_IF (self->handler),
                                                       &return_value,
                                                       vlan_id,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_vlan",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_delete_vlan implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_vlan",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_add_ports_to_vlan (switch_sai_rpcProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftAddPortsToVlanArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint vlan_id;
    GPtrArray * thrift_port_list;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftAddPortsToVlanResult * result_struct;

    g_object_get (args,
                  "vlan_id", &vlan_id,
                  "thrift_port_list", &thrift_port_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_add_ports_to_vlan (SWITCH_SAI_RPC_IF (self->handler),
                                                             &return_value,
                                                             vlan_id,
                                                             thrift_port_list,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_add_ports_to_vlan",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_add_ports_to_vlan implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_add_ports_to_vlan",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_port_list != NULL)
      g_ptr_array_unref (thrift_port_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_ports_from_vlan (switch_sai_rpcProcessor *self,
                                                                    gint32 sequence_id,
                                                                    ThriftProtocol *input_protocol,
                                                                    ThriftProtocol *output_protocol,
                                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemovePortsFromVlanArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint vlan_id;
    GPtrArray * thrift_port_list;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemovePortsFromVlanResult * result_struct;

    g_object_get (args,
                  "vlan_id", &vlan_id,
                  "thrift_port_list", &thrift_port_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_ports_from_vlan (SWITCH_SAI_RPC_IF (self->handler),
                                                                  &return_value,
                                                                  vlan_id,
                                                                  thrift_port_list,
                                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_ports_from_vlan",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_ports_from_vlan implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_ports_from_vlan",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_port_list != NULL)
      g_ptr_array_unref (thrift_port_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_vlan_stats (switch_sai_rpcProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftGetVlanStatsArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint vlan_id;
    GArray * counter_ids;
    gint number_of_counters;
    GArray * return_value;
    switch_sai_rpcSaiThriftGetVlanStatsResult * result_struct;

    g_object_get (args,
                  "vlan_id", &vlan_id,
                  "counter_ids", &counter_ids,
                  "number_of_counters", &number_of_counters,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_get_vlan_stats (SWITCH_SAI_RPC_IF (self->handler),
                                                          &return_value,
                                                          vlan_id,
                                                          counter_ids,
                                                          number_of_counters,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_vlan_stats",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_get_vlan_stats implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_vlan_stats",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (counter_ids != NULL)
      g_array_unref (counter_ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_virtual_router (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateVirtualRouterArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateVirtualRouterResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_virtual_router (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 thrift_attr_list,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_virtual_router",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_virtual_router implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_virtual_router",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_virtual_router (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveVirtualRouterArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t vr_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveVirtualRouterResult * result_struct;

    g_object_get (args,
                  "vr_id", &vr_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_virtual_router (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 vr_id,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_virtual_router",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_virtual_router implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_virtual_router",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_route (switch_sai_rpcProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateRouteArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry;
    GPtrArray * thrift_attr_list;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftCreateRouteResult * result_struct;

    g_object_get (args,
                  "thrift_unicast_route_entry", &thrift_unicast_route_entry,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_route (SWITCH_SAI_RPC_IF (self->handler),
                                                        &return_value,
                                                        thrift_unicast_route_entry,
                                                        thrift_attr_list,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_route",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_route implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_route",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_unicast_route_entry != NULL)
      g_object_unref (thrift_unicast_route_entry);
    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_route (switch_sai_rpcProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveRouteArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_unicast_route_entry_t * thrift_unicast_route_entry;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveRouteResult * result_struct;

    g_object_get (args,
                  "thrift_unicast_route_entry", &thrift_unicast_route_entry,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_route (SWITCH_SAI_RPC_IF (self->handler),
                                                        &return_value,
                                                        thrift_unicast_route_entry,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_route",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_route implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_route",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_unicast_route_entry != NULL)
      g_object_unref (thrift_unicast_route_entry);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_router_interface (switch_sai_rpcProcessor *self,
                                                                     gint32 sequence_id,
                                                                     ThriftProtocol *input_protocol,
                                                                     ThriftProtocol *output_protocol,
                                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateRouterInterfaceArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateRouterInterfaceResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_router_interface (SWITCH_SAI_RPC_IF (self->handler),
                                                                   &return_value,
                                                                   thrift_attr_list,
                                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_router_interface",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_router_interface implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_router_interface",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_router_interface (switch_sai_rpcProcessor *self,
                                                                     gint32 sequence_id,
                                                                     ThriftProtocol *input_protocol,
                                                                     ThriftProtocol *output_protocol,
                                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t rif_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveRouterInterfaceResult * result_struct;

    g_object_get (args,
                  "rif_id", &rif_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_router_interface (SWITCH_SAI_RPC_IF (self->handler),
                                                                   &return_value,
                                                                   rif_id,
                                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_router_interface",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_router_interface implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_router_interface",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_next_hop (switch_sai_rpcProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateNextHopArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateNextHopResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_next_hop (SWITCH_SAI_RPC_IF (self->handler),
                                                           &return_value,
                                                           thrift_attr_list,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_next_hop",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_next_hop implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_next_hop",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_next_hop (switch_sai_rpcProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveNextHopArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t next_hop_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveNextHopResult * result_struct;

    g_object_get (args,
                  "next_hop_id", &next_hop_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_next_hop (SWITCH_SAI_RPC_IF (self->handler),
                                                           &return_value,
                                                           next_hop_id,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_next_hop",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_next_hop implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_next_hop",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_next_hop_group (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateNextHopGroupArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateNextHopGroupResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_next_hop_group (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 thrift_attr_list,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_next_hop_group",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_next_hop_group implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_next_hop_group",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_next_hop_group (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveNextHopGroupArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t next_hop_group_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveNextHopGroupResult * result_struct;

    g_object_get (args,
                  "next_hop_group_id", &next_hop_group_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_next_hop_group (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 next_hop_group_id,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_next_hop_group",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_next_hop_group implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_next_hop_group",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_add_next_hop_to_group (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftAddNextHopToGroupArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t next_hop_group_id;
    GArray * thrift_nexthops;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftAddNextHopToGroupResult * result_struct;

    g_object_get (args,
                  "next_hop_group_id", &next_hop_group_id,
                  "thrift_nexthops", &thrift_nexthops,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_add_next_hop_to_group (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 next_hop_group_id,
                                                                 thrift_nexthops,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_add_next_hop_to_group",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_add_next_hop_to_group implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_add_next_hop_to_group",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_nexthops != NULL)
      g_array_unref (thrift_nexthops);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_next_hop_from_group (switch_sai_rpcProcessor *self,
                                                                        gint32 sequence_id,
                                                                        ThriftProtocol *input_protocol,
                                                                        ThriftProtocol *output_protocol,
                                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t next_hop_group_id;
    GArray * thrift_nexthops;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult * result_struct;

    g_object_get (args,
                  "next_hop_group_id", &next_hop_group_id,
                  "thrift_nexthops", &thrift_nexthops,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_next_hop_from_group (SWITCH_SAI_RPC_IF (self->handler),
                                                                      &return_value,
                                                                      next_hop_group_id,
                                                                      thrift_nexthops,
                                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_next_hop_from_group",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_next_hop_from_group implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_next_hop_from_group",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_nexthops != NULL)
      g_array_unref (thrift_nexthops);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_lag (switch_sai_rpcProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateLagArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateLagResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_lag (SWITCH_SAI_RPC_IF (self->handler),
                                                      &return_value,
                                                      thrift_attr_list,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_lag",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_lag implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_lag",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_lag (switch_sai_rpcProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveLagArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t lag_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveLagResult * result_struct;

    g_object_get (args,
                  "lag_id", &lag_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_lag (SWITCH_SAI_RPC_IF (self->handler),
                                                      &return_value,
                                                      lag_id,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_lag",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_lag implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_lag",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_lag_member (switch_sai_rpcProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateLagMemberArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateLagMemberResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_lag_member (SWITCH_SAI_RPC_IF (self->handler),
                                                             &return_value,
                                                             thrift_attr_list,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_lag_member",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_lag_member implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_lag_member",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_lag_member (switch_sai_rpcProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveLagMemberArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t lag_member_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveLagMemberResult * result_struct;

    g_object_get (args,
                  "lag_member_id", &lag_member_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_lag_member (SWITCH_SAI_RPC_IF (self->handler),
                                                             &return_value,
                                                             lag_member_id,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_lag_member",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_lag_member implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_lag_member",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_stp_entry (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateStpEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateStpEntryResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_stp_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            thrift_attr_list,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_stp_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_stp_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_stp_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_stp_entry (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveStpEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t stp_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveStpEntryResult * result_struct;

    g_object_get (args,
                  "stp_id", &stp_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_stp_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            stp_id,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_stp_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_stp_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_stp_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_stp_port_state (switch_sai_rpcProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftSetStpPortStateArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t stp_id;
    sai_thrift_object_id_t port_id;
    sai_thrift_port_stp_port_state_t stp_port_state;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftSetStpPortStateResult * result_struct;

    g_object_get (args,
                  "stp_id", &stp_id,
                  "port_id", &port_id,
                  "stp_port_state", &stp_port_state,
                  NULL);
    /* can't get stp_port_state by g_object_get */
    stp_port_state = args->stp_port_state;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_set_stp_port_state (SWITCH_SAI_RPC_IF (self->handler),
                                                              &return_value,
                                                              stp_id,
                                                              port_id,
                                                              stp_port_state,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_stp_port_state",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_set_stp_port_state implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_stp_port_state",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_stp_port_state (switch_sai_rpcProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftGetStpPortStateArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t stp_id;
    sai_thrift_object_id_t port_id;
    sai_thrift_port_stp_port_state_t return_value;
    switch_sai_rpcSaiThriftGetStpPortStateResult * result_struct;

    g_object_get (args,
                  "stp_id", &stp_id,
                  "port_id", &port_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_get_stp_port_state (SWITCH_SAI_RPC_IF (self->handler),
                                                              &return_value,
                                                              stp_id,
                                                              port_id,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_stp_port_state",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_get_stp_port_state implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_stp_port_state",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_neighbor_entry (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateNeighborEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_neighbor_entry_t * thrift_neighbor_entry;
    GPtrArray * thrift_attr_list;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftCreateNeighborEntryResult * result_struct;

    g_object_get (args,
                  "thrift_neighbor_entry", &thrift_neighbor_entry,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_neighbor_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 thrift_neighbor_entry,
                                                                 thrift_attr_list,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_neighbor_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_neighbor_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_neighbor_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_neighbor_entry != NULL)
      g_object_unref (thrift_neighbor_entry);
    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_neighbor_entry (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveNeighborEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_neighbor_entry_t * thrift_neighbor_entry;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveNeighborEntryResult * result_struct;

    g_object_get (args,
                  "thrift_neighbor_entry", &thrift_neighbor_entry,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_neighbor_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 thrift_neighbor_entry,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_neighbor_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_neighbor_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_neighbor_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_neighbor_entry != NULL)
      g_object_unref (thrift_neighbor_entry);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_switch_attribute (switch_sai_rpcProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftGetSwitchAttributeArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_attribute_list_t * return_value;
    switch_sai_rpcSaiThriftGetSwitchAttributeResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_get_switch_attribute (SWITCH_SAI_RPC_IF (self->handler),
                                                                &return_value,
                                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_switch_attribute",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_get_switch_attribute implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_switch_attribute",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_switch_attribute (switch_sai_rpcProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftSetSwitchAttributeArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_attribute_t * attribute;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftSetSwitchAttributeResult * result_struct;

    g_object_get (args,
                  "attribute", &attribute,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_set_switch_attribute (SWITCH_SAI_RPC_IF (self->handler),
                                                                &return_value,
                                                                attribute,
                                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_switch_attribute",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_set_switch_attribute implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_switch_attribute",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (attribute != NULL)
      g_object_unref (attribute);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_hostif (switch_sai_rpcProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateHostifArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateHostifResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_hostif (SWITCH_SAI_RPC_IF (self->handler),
                                                         &return_value,
                                                         thrift_attr_list,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_hostif",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_hostif implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_hostif",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_hostif (switch_sai_rpcProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveHostifArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t hif_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveHostifResult * result_struct;

    g_object_get (args,
                  "hif_id", &hif_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_hostif (SWITCH_SAI_RPC_IF (self->handler),
                                                         &return_value,
                                                         hif_id,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_hostif",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_hostif implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_hostif",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_hostif_trap_group (switch_sai_rpcProcessor *self,
                                                                      gint32 sequence_id,
                                                                      ThriftProtocol *input_protocol,
                                                                      ThriftProtocol *output_protocol,
                                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateHostifTrapGroupResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_hostif_trap_group (SWITCH_SAI_RPC_IF (self->handler),
                                                                    &return_value,
                                                                    thrift_attr_list,
                                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_hostif_trap_group",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_hostif_trap_group implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_hostif_trap_group",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_hostif_trap_group (switch_sai_rpcProcessor *self,
                                                                      gint32 sequence_id,
                                                                      ThriftProtocol *input_protocol,
                                                                      ThriftProtocol *output_protocol,
                                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t trap_group_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult * result_struct;

    g_object_get (args,
                  "trap_group_id", &trap_group_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_hostif_trap_group (SWITCH_SAI_RPC_IF (self->handler),
                                                                    &return_value,
                                                                    trap_group_id,
                                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_hostif_trap_group",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_hostif_trap_group implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_hostif_trap_group",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_hostif_trap (switch_sai_rpcProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateHostifTrapArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftCreateHostifTrapResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_hostif_trap (SWITCH_SAI_RPC_IF (self->handler),
                                                              &return_value,
                                                              thrift_attr_list,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_hostif_trap",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_hostif_trap implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_hostif_trap",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_hostif_trap (switch_sai_rpcProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveHostifTrapArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_hostif_trap_id_t trap_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveHostifTrapResult * result_struct;

    g_object_get (args,
                  "trap_id", &trap_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_hostif_trap (SWITCH_SAI_RPC_IF (self->handler),
                                                              &return_value,
                                                              trap_id,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_hostif_trap",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_hostif_trap implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_hostif_trap",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_set_hostif_trap (switch_sai_rpcProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftSetHostifTrapArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_hostif_trap_id_t trap_id;
    sai_thrift_attribute_t * thrift_attr;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftSetHostifTrapResult * result_struct;

    g_object_get (args,
                  "trap_id", &trap_id,
                  "thrift_attr", &thrift_attr,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_set_hostif_trap (SWITCH_SAI_RPC_IF (self->handler),
                                                           &return_value,
                                                           trap_id,
                                                           thrift_attr,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_hostif_trap",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_set_hostif_trap implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_set_hostif_trap",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr != NULL)
      g_object_unref (thrift_attr);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_acl_table (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateAclTableArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateAclTableResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_acl_table (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            thrift_attr_list,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_acl_table",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_acl_table implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_acl_table",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_acl_table (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftDeleteAclTableArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t acl_table_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftDeleteAclTableResult * result_struct;

    g_object_get (args,
                  "acl_table_id", &acl_table_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_delete_acl_table (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            acl_table_id,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_acl_table",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_delete_acl_table implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_acl_table",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_acl_entry (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateAclEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateAclEntryResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_acl_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            thrift_attr_list,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_acl_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_acl_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_acl_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_acl_entry (switch_sai_rpcProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftDeleteAclEntryArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t acl_entry;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftDeleteAclEntryResult * result_struct;

    g_object_get (args,
                  "acl_entry", &acl_entry,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_delete_acl_entry (SWITCH_SAI_RPC_IF (self->handler),
                                                            &return_value,
                                                            acl_entry,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_acl_entry",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_delete_acl_entry implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_acl_entry",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_acl_counter (switch_sai_rpcProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateAclCounterArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateAclCounterResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_acl_counter (SWITCH_SAI_RPC_IF (self->handler),
                                                              &return_value,
                                                              thrift_attr_list,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_acl_counter",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_acl_counter implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_acl_counter",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_delete_acl_counter (switch_sai_rpcProcessor *self,
                                                                gint32 sequence_id,
                                                                ThriftProtocol *input_protocol,
                                                                ThriftProtocol *output_protocol,
                                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftDeleteAclCounterArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t acl_counter_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftDeleteAclCounterResult * result_struct;

    g_object_get (args,
                  "acl_counter_id", &acl_counter_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_delete_acl_counter (SWITCH_SAI_RPC_IF (self->handler),
                                                              &return_value,
                                                              acl_counter_id,
                                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_acl_counter",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_delete_acl_counter implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_delete_acl_counter",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_acl_counter_attribute (switch_sai_rpcProcessor *self,
                                                                       gint32 sequence_id,
                                                                       ThriftProtocol *input_protocol,
                                                                       ThriftProtocol *output_protocol,
                                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftGetAclCounterAttributeArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t acl_counter_id;
    GArray * thrift_attr_ids;
    GPtrArray * return_value;
    switch_sai_rpcSaiThriftGetAclCounterAttributeResult * result_struct;

    g_object_get (args,
                  "acl_counter_id", &acl_counter_id,
                  "thrift_attr_ids", &thrift_attr_ids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_get_acl_counter_attribute (SWITCH_SAI_RPC_IF (self->handler),
                                                                     &return_value,
                                                                     acl_counter_id,
                                                                     thrift_attr_ids,
                                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
//      if (return_value != NULL)
//        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_acl_counter_attribute",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_get_acl_counter_attribute implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_acl_counter_attribute",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_ids != NULL)
      g_array_unref (thrift_attr_ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_mirror_session (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreateMirrorSessionArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreateMirrorSessionResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_mirror_session (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 thrift_attr_list,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_mirror_session",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_mirror_session implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_mirror_session",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_mirror_session (switch_sai_rpcProcessor *self,
                                                                   gint32 sequence_id,
                                                                   ThriftProtocol *input_protocol,
                                                                   ThriftProtocol *output_protocol,
                                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemoveMirrorSessionArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t session_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemoveMirrorSessionResult * result_struct;

    g_object_get (args,
                  "session_id", &session_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_mirror_session (SWITCH_SAI_RPC_IF (self->handler),
                                                                 &return_value,
                                                                 session_id,
                                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_mirror_session",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_mirror_session implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_mirror_session",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_create_policer (switch_sai_rpcProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftCreatePolicerArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * thrift_attr_list;
    sai_thrift_object_id_t return_value;
    switch_sai_rpcSaiThriftCreatePolicerResult * result_struct;

    g_object_get (args,
                  "thrift_attr_list", &thrift_attr_list,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_create_policer (SWITCH_SAI_RPC_IF (self->handler),
                                                          &return_value,
                                                          thrift_attr_list,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_policer",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_create_policer implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_create_policer",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (thrift_attr_list != NULL)
      g_ptr_array_unref (thrift_attr_list);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_remove_policer (switch_sai_rpcProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftRemovePolicerArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t policer_id;
    sai_thrift_status_t return_value;
    switch_sai_rpcSaiThriftRemovePolicerResult * result_struct;

    g_object_get (args,
                  "policer_id", &policer_id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_remove_policer (SWITCH_SAI_RPC_IF (self->handler),
                                                          &return_value,
                                                          policer_id,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_policer",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_remove_policer implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_remove_policer",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_process_sai_thrift_get_policer_stats (switch_sai_rpcProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  switch_sai_rpcSaiThriftGetPolicerStatsArgs * args =
    g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    sai_thrift_object_id_t policer_id;
    GArray * counter_ids;
    GArray * return_value;
    switch_sai_rpcSaiThriftGetPolicerStatsResult * result_struct;

    g_object_get (args,
                  "policer_id", &policer_id,
                  "counter_ids", &counter_ids,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (switch_sai_rpc_handler_sai_thrift_get_policer_stats (SWITCH_SAI_RPC_IF (self->handler),
                                                             &return_value,
                                                             policer_id,
                                                             counter_ids,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_policer_stats",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (*error == NULL)
        g_warning ("switch_sai_rpc.sai_thrift_get_policer_stats implementation returned FALSE "
                   "but did not set an error");

      xception =
        g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                      "type",    *error != NULL ? (*error)->code :
                                 THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                      "message", *error != NULL ? (*error)->message : NULL,
                      NULL);
      g_clear_error (error);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sai_thrift_get_policer_stats",
                                               T_EXCEPTION,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (xception),
                               output_protocol,
                               error) != -1));

      g_object_unref (xception);
    }

    if (counter_ids != NULL)
      g_array_unref (counter_ids);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
switch_sai_rpc_processor_dispatch_call (ThriftDispatchProcessor *dispatch_processor,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        gchar *method_name,
                                        gint32 sequence_id,
                                        GError **error)
{
  switch_sai_rpc_processor_process_function_def *process_function_def;
  gboolean dispatch_result = FALSE;

  switch_sai_rpcProcessor *self = SWITCH_SAI_RPC_PROCESSOR (dispatch_processor);
  ThriftDispatchProcessorClass *parent_class =
    g_type_class_peek_parent (SWITCH_SAI_RPC_PROCESSOR_GET_CLASS (self));

  process_function_def = g_hash_table_lookup (self->process_map, method_name);
  if (process_function_def != NULL)
  {
    dispatch_result = (*process_function_def->function) (self,
                                                         sequence_id,
                                                         input_protocol,
                                                         output_protocol,
                                                         error);
  }
  else
  {
    dispatch_result = parent_class->dispatch_call (dispatch_processor,
                                                   input_protocol,
                                                   output_protocol,
                                                   method_name,
                                                   sequence_id,
                                                   error);
  }

  return dispatch_result;
}

static void
switch_sai_rpc_processor_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  switch_sai_rpcProcessor *self = SWITCH_SAI_RPC_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_PROCESSOR_HANDLER:
      if (self->handler != NULL)
        g_object_unref (self->handler);
      self->handler = g_value_get_object (value);
      g_object_ref (self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_processor_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  switch_sai_rpcProcessor *self = SWITCH_SAI_RPC_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_PROCESSOR_HANDLER:
      g_value_set_object (value, self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_processor_dispose (GObject *gobject)
{
  switch_sai_rpcProcessor *self = SWITCH_SAI_RPC_PROCESSOR (gobject);

  if (self->handler != NULL)
  {
    g_object_unref (self->handler);
    self->handler = NULL;
  }

  G_OBJECT_CLASS (switch_sai_rpc_processor_parent_class)->dispose (gobject);
}

static void
switch_sai_rpc_processor_finalize (GObject *gobject)
{
  switch_sai_rpcProcessor *self = SWITCH_SAI_RPC_PROCESSOR (gobject);

  g_hash_table_destroy (self->process_map);

  G_OBJECT_CLASS (switch_sai_rpc_processor_parent_class)->finalize (gobject);
}

static void
switch_sai_rpc_processor_init (switch_sai_rpcProcessor *self)
{
  guint index;

  self->handler = NULL;
  self->process_map = g_hash_table_new (g_str_hash, g_str_equal);

  for (index = 0; index < 52; index += 1)
    g_hash_table_insert (self->process_map,
                         switch_sai_rpc_processor_process_function_defs[index].name,
                         &switch_sai_rpc_processor_process_function_defs[index]);
}

static void
switch_sai_rpc_processor_class_init (switch_sai_rpcProcessorClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftDispatchProcessorClass *dispatch_processor_class =
    THRIFT_DISPATCH_PROCESSOR_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->dispose = switch_sai_rpc_processor_dispose;
  gobject_class->finalize = switch_sai_rpc_processor_finalize;
  gobject_class->set_property = switch_sai_rpc_processor_set_property;
  gobject_class->get_property = switch_sai_rpc_processor_get_property;

  dispatch_processor_class->dispatch_call = switch_sai_rpc_processor_dispatch_call;
  cls->dispatch_call = switch_sai_rpc_processor_dispatch_call;

  param_spec = g_param_spec_object ("handler",
                                    "Service handler implementation",
                                    "The service handler implementation "
                                    "to which method calls are dispatched.",
                                    TYPE_SWITCH_SAI_RPC_HANDLER,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_SWITCH_SAI_RPC_PROCESSOR_HANDLER,
                                   param_spec);
}
