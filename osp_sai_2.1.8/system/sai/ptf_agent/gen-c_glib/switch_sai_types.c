/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "switch_sai_types.h"
#include <thrift/c_glib/thrift.h>

enum _sai_thrift_fdb_entry_tProperties
{
  PROP_SAI_THRIFT_FDB_ENTRY_T_0,
  PROP_SAI_THRIFT_FDB_ENTRY_T_MAC_ADDRESS,
  PROP_SAI_THRIFT_FDB_ENTRY_T_VLAN_ID
};

/* reads a sai_thrift_fdb_entry_t object */
static gint32
sai_thrift_fdb_entry_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_fdb_entry_t * this_object = SAI_THRIFT_FDB_ENTRY_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->mac_address != NULL)
          {
            g_free(this_object->mac_address);
            this_object->mac_address = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mac_address, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mac_address = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->vlan_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vlan_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_fdb_entry_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_fdb_entry_t * this_object = SAI_THRIFT_FDB_ENTRY_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_fdb_entry_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mac_address", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->mac_address, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->vlan_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_fdb_entry_t_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_fdb_entry_t *self = SAI_THRIFT_FDB_ENTRY_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_FDB_ENTRY_T_MAC_ADDRESS:
      if (self->mac_address != NULL)
        g_free (self->mac_address);
      self->mac_address = g_value_dup_string (value);
      self->__isset_mac_address = TRUE;
      break;

    case PROP_SAI_THRIFT_FDB_ENTRY_T_VLAN_ID:
      self->vlan_id = g_value_get_int (value);
      self->__isset_vlan_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_fdb_entry_t_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_fdb_entry_t *self = SAI_THRIFT_FDB_ENTRY_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_FDB_ENTRY_T_MAC_ADDRESS:
      g_value_set_string (value, self->mac_address);
      break;

    case PROP_SAI_THRIFT_FDB_ENTRY_T_VLAN_ID:
      g_value_set_int (value, self->vlan_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_fdb_entry_t_instance_init (sai_thrift_fdb_entry_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->mac_address = NULL;
  object->__isset_mac_address = FALSE;
  object->vlan_id = 0;
  object->__isset_vlan_id = FALSE;
}

static void 
sai_thrift_fdb_entry_t_finalize (GObject *object)
{
  sai_thrift_fdb_entry_t *tobject = SAI_THRIFT_FDB_ENTRY_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mac_address != NULL)
  {
    g_free(tobject->mac_address);
    tobject->mac_address = NULL;
  }
}

static void
sai_thrift_fdb_entry_t_class_init (sai_thrift_fdb_entry_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_fdb_entry_t_read;
  struct_class->write = sai_thrift_fdb_entry_t_write;

  gobject_class->finalize = sai_thrift_fdb_entry_t_finalize;
  gobject_class->get_property = sai_thrift_fdb_entry_t_get_property;
  gobject_class->set_property = sai_thrift_fdb_entry_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_FDB_ENTRY_T_MAC_ADDRESS,
     g_param_spec_string ("mac_address",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_FDB_ENTRY_T_VLAN_ID,
     g_param_spec_int ("vlan_id",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
sai_thrift_fdb_entry_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_fdb_entry_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_fdb_entry_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_fdb_entry_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_fdb_entry_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_fdb_entry_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_vlan_port_tProperties
{
  PROP_SAI_THRIFT_VLAN_PORT_T_0,
  PROP_SAI_THRIFT_VLAN_PORT_T_PORT_ID,
  PROP_SAI_THRIFT_VLAN_PORT_T_TAGGING_MODE
};

/* reads a sai_thrift_vlan_port_t object */
static gint32
sai_thrift_vlan_port_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_vlan_port_t * this_object = SAI_THRIFT_VLAN_PORT_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->port_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->tagging_mode, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_tagging_mode = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_vlan_port_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_vlan_port_t * this_object = SAI_THRIFT_VLAN_PORT_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_vlan_port_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->port_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tagging_mode", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->tagging_mode, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_vlan_port_t_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_vlan_port_t *self = SAI_THRIFT_VLAN_PORT_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_VLAN_PORT_T_PORT_ID:
      self->port_id = g_value_get_int64 (value);
      self->__isset_port_id = TRUE;
      break;

    case PROP_SAI_THRIFT_VLAN_PORT_T_TAGGING_MODE:
      self->tagging_mode = g_value_get_int (value);
      self->__isset_tagging_mode = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_vlan_port_t_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_vlan_port_t *self = SAI_THRIFT_VLAN_PORT_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_VLAN_PORT_T_PORT_ID:
      g_value_set_int64 (value, self->port_id);
      break;

    case PROP_SAI_THRIFT_VLAN_PORT_T_TAGGING_MODE:
      g_value_set_int (value, self->tagging_mode);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_vlan_port_t_instance_init (sai_thrift_vlan_port_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->port_id = 0;
  object->__isset_port_id = FALSE;
  object->tagging_mode = 0;
  object->__isset_tagging_mode = FALSE;
}

static void 
sai_thrift_vlan_port_t_finalize (GObject *object)
{
  sai_thrift_vlan_port_t *tobject = SAI_THRIFT_VLAN_PORT_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
sai_thrift_vlan_port_t_class_init (sai_thrift_vlan_port_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_vlan_port_t_read;
  struct_class->write = sai_thrift_vlan_port_t_write;

  gobject_class->finalize = sai_thrift_vlan_port_t_finalize;
  gobject_class->get_property = sai_thrift_vlan_port_t_get_property;
  gobject_class->set_property = sai_thrift_vlan_port_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_VLAN_PORT_T_PORT_ID,
     g_param_spec_int64 ("port_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_VLAN_PORT_T_TAGGING_MODE,
     g_param_spec_int ("tagging_mode",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
sai_thrift_vlan_port_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_vlan_port_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_vlan_port_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_vlan_port_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_vlan_port_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_vlan_port_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_ip_tProperties
{
  PROP_SAI_THRIFT_IP_T_0,
  PROP_SAI_THRIFT_IP_T_IP4,
  PROP_SAI_THRIFT_IP_T_IP6
};

/* reads a sai_thrift_ip_t object */
static gint32
sai_thrift_ip_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_ip_t * this_object = SAI_THRIFT_IP_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->ip4 != NULL)
          {
            g_free(this_object->ip4);
            this_object->ip4 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->ip6 != NULL)
          {
            g_free(this_object->ip6);
            this_object->ip6 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_ip_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_ip_t * this_object = SAI_THRIFT_IP_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_ip_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip4", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip4, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip6", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip6, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_ip_t_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  sai_thrift_ip_t *self = SAI_THRIFT_IP_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_IP_T_IP4:
      if (self->ip4 != NULL)
        g_free (self->ip4);
      self->ip4 = g_value_dup_string (value);
      self->__isset_ip4 = TRUE;
      break;

    case PROP_SAI_THRIFT_IP_T_IP6:
      if (self->ip6 != NULL)
        g_free (self->ip6);
      self->ip6 = g_value_dup_string (value);
      self->__isset_ip6 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_ip_t_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  sai_thrift_ip_t *self = SAI_THRIFT_IP_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_IP_T_IP4:
      g_value_set_string (value, self->ip4);
      break;

    case PROP_SAI_THRIFT_IP_T_IP6:
      g_value_set_string (value, self->ip6);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_ip_t_instance_init (sai_thrift_ip_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ip4 = NULL;
  object->__isset_ip4 = FALSE;
  object->ip6 = NULL;
  object->__isset_ip6 = FALSE;
}

static void 
sai_thrift_ip_t_finalize (GObject *object)
{
  sai_thrift_ip_t *tobject = SAI_THRIFT_IP_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ip4 != NULL)
  {
    g_free(tobject->ip4);
    tobject->ip4 = NULL;
  }
  if (tobject->ip6 != NULL)
  {
    g_free(tobject->ip6);
    tobject->ip6 = NULL;
  }
}

static void
sai_thrift_ip_t_class_init (sai_thrift_ip_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_ip_t_read;
  struct_class->write = sai_thrift_ip_t_write;

  gobject_class->finalize = sai_thrift_ip_t_finalize;
  gobject_class->get_property = sai_thrift_ip_t_get_property;
  gobject_class->set_property = sai_thrift_ip_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_IP_T_IP4,
     g_param_spec_string ("ip4",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_IP_T_IP6,
     g_param_spec_string ("ip6",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
sai_thrift_ip_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_ip_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_ip_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_ip_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_ip_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_ip_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_ip_address_tProperties
{
  PROP_SAI_THRIFT_IP_ADDRESS_T_0,
  PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR_FAMILY,
  PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR
};

/* reads a sai_thrift_ip_address_t object */
static gint32
sai_thrift_ip_address_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_ip_address_t * this_object = SAI_THRIFT_IP_ADDRESS_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->addr_family, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_addr_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->addr), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_addr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_ip_address_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_ip_address_t * this_object = SAI_THRIFT_IP_ADDRESS_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_ip_address_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "addr_family", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->addr_family, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "addr", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->addr), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_ip_address_t_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  sai_thrift_ip_address_t *self = SAI_THRIFT_IP_ADDRESS_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR_FAMILY:
      self->addr_family = g_value_get_int (value);
      self->__isset_addr_family = TRUE;
      break;

    case PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR:
      if (self->addr != NULL)
        g_object_unref (self->addr);
      self->addr = g_value_dup_object (value);
      self->__isset_addr = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_ip_address_t_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  sai_thrift_ip_address_t *self = SAI_THRIFT_IP_ADDRESS_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR_FAMILY:
      g_value_set_int (value, self->addr_family);
      break;

    case PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR:
      g_value_set_object (value, self->addr);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_ip_address_t_instance_init (sai_thrift_ip_address_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->addr_family = 0;
  object->__isset_addr_family = FALSE;
  object->addr = g_object_new (TYPE_SAI_THRIFT_IP_T, NULL);
  object->__isset_addr = FALSE;
}

static void 
sai_thrift_ip_address_t_finalize (GObject *object)
{
  sai_thrift_ip_address_t *tobject = SAI_THRIFT_IP_ADDRESS_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->addr != NULL)
  {
    g_object_unref(tobject->addr);
    tobject->addr = NULL;
  }
}

static void
sai_thrift_ip_address_t_class_init (sai_thrift_ip_address_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_ip_address_t_read;
  struct_class->write = sai_thrift_ip_address_t_write;

  gobject_class->finalize = sai_thrift_ip_address_t_finalize;
  gobject_class->get_property = sai_thrift_ip_address_t_get_property;
  gobject_class->set_property = sai_thrift_ip_address_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR_FAMILY,
     g_param_spec_int ("addr_family",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_IP_ADDRESS_T_ADDR,
     g_param_spec_object ("addr",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_IP_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_ip_address_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_ip_address_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_ip_address_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_ip_address_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_ip_address_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_ip_address_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_ip_prefix_tProperties
{
  PROP_SAI_THRIFT_IP_PREFIX_T_0,
  PROP_SAI_THRIFT_IP_PREFIX_T_ADDR_FAMILY,
  PROP_SAI_THRIFT_IP_PREFIX_T_ADDR,
  PROP_SAI_THRIFT_IP_PREFIX_T_MASK
};

/* reads a sai_thrift_ip_prefix_t object */
static gint32
sai_thrift_ip_prefix_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_ip_prefix_t * this_object = SAI_THRIFT_IP_PREFIX_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->addr_family, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_addr_family = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->addr), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_addr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mask), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mask = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_ip_prefix_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_ip_prefix_t * this_object = SAI_THRIFT_IP_PREFIX_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_ip_prefix_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "addr_family", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->addr_family, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "addr", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->addr), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mask", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mask), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_ip_prefix_t_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_ip_prefix_t *self = SAI_THRIFT_IP_PREFIX_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_IP_PREFIX_T_ADDR_FAMILY:
      self->addr_family = g_value_get_int (value);
      self->__isset_addr_family = TRUE;
      break;

    case PROP_SAI_THRIFT_IP_PREFIX_T_ADDR:
      if (self->addr != NULL)
        g_object_unref (self->addr);
      self->addr = g_value_dup_object (value);
      self->__isset_addr = TRUE;
      break;

    case PROP_SAI_THRIFT_IP_PREFIX_T_MASK:
      if (self->mask != NULL)
        g_object_unref (self->mask);
      self->mask = g_value_dup_object (value);
      self->__isset_mask = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_ip_prefix_t_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_ip_prefix_t *self = SAI_THRIFT_IP_PREFIX_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_IP_PREFIX_T_ADDR_FAMILY:
      g_value_set_int (value, self->addr_family);
      break;

    case PROP_SAI_THRIFT_IP_PREFIX_T_ADDR:
      g_value_set_object (value, self->addr);
      break;

    case PROP_SAI_THRIFT_IP_PREFIX_T_MASK:
      g_value_set_object (value, self->mask);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_ip_prefix_t_instance_init (sai_thrift_ip_prefix_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->addr_family = 0;
  object->__isset_addr_family = FALSE;
  object->addr = g_object_new (TYPE_SAI_THRIFT_IP_T, NULL);
  object->__isset_addr = FALSE;
  object->mask = g_object_new (TYPE_SAI_THRIFT_IP_T, NULL);
  object->__isset_mask = FALSE;
}

static void 
sai_thrift_ip_prefix_t_finalize (GObject *object)
{
  sai_thrift_ip_prefix_t *tobject = SAI_THRIFT_IP_PREFIX_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->addr != NULL)
  {
    g_object_unref(tobject->addr);
    tobject->addr = NULL;
  }
  if (tobject->mask != NULL)
  {
    g_object_unref(tobject->mask);
    tobject->mask = NULL;
  }
}

static void
sai_thrift_ip_prefix_t_class_init (sai_thrift_ip_prefix_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_ip_prefix_t_read;
  struct_class->write = sai_thrift_ip_prefix_t_write;

  gobject_class->finalize = sai_thrift_ip_prefix_t_finalize;
  gobject_class->get_property = sai_thrift_ip_prefix_t_get_property;
  gobject_class->set_property = sai_thrift_ip_prefix_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_IP_PREFIX_T_ADDR_FAMILY,
     g_param_spec_int ("addr_family",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_IP_PREFIX_T_ADDR,
     g_param_spec_object ("addr",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_IP_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_IP_PREFIX_T_MASK,
     g_param_spec_object ("mask",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_IP_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_ip_prefix_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_ip_prefix_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_ip_prefix_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_ip_prefix_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_ip_prefix_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_ip_prefix_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_object_list_tProperties
{
  PROP_SAI_THRIFT_OBJECT_LIST_T_0,
  PROP_SAI_THRIFT_OBJECT_LIST_T_COUNT,
  PROP_SAI_THRIFT_OBJECT_LIST_T_OBJECT_ID_LIST
};

/* reads a sai_thrift_object_list_t object */
static gint32
sai_thrift_object_list_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_object_list_t * this_object = SAI_THRIFT_OBJECT_LIST_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem0 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->object_id_list, _elem0, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_object_id_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_object_list_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_object_list_t * this_object = SAI_THRIFT_OBJECT_LIST_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_object_list_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "object_id_list", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i1;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->object_id_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i1 = 0; i1 < this_object->object_id_list->len; i1++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->object_id_list, gint64, i1)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_object_list_t_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  sai_thrift_object_list_t *self = SAI_THRIFT_OBJECT_LIST_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_OBJECT_LIST_T_COUNT:
      self->count = g_value_get_int (value);
      self->__isset_count = TRUE;
      break;

    case PROP_SAI_THRIFT_OBJECT_LIST_T_OBJECT_ID_LIST:
      if (self->object_id_list != NULL)
        g_array_unref (self->object_id_list);
      self->object_id_list = g_value_dup_boxed (value);
      self->__isset_object_id_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_object_list_t_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  sai_thrift_object_list_t *self = SAI_THRIFT_OBJECT_LIST_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_OBJECT_LIST_T_COUNT:
      g_value_set_int (value, self->count);
      break;

    case PROP_SAI_THRIFT_OBJECT_LIST_T_OBJECT_ID_LIST:
      g_value_set_boxed (value, self->object_id_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_object_list_t_instance_init (sai_thrift_object_list_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->count = 0;
  object->__isset_count = FALSE;
  object->object_id_list = g_array_new (0, 1, sizeof (gint64));
  object->__isset_object_id_list = FALSE;
}

static void 
sai_thrift_object_list_t_finalize (GObject *object)
{
  sai_thrift_object_list_t *tobject = SAI_THRIFT_OBJECT_LIST_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->object_id_list != NULL)
  {
    g_array_unref (tobject->object_id_list);
    tobject->object_id_list = NULL;
  }
}

static void
sai_thrift_object_list_t_class_init (sai_thrift_object_list_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_object_list_t_read;
  struct_class->write = sai_thrift_object_list_t_write;

  gobject_class->finalize = sai_thrift_object_list_t_finalize;
  gobject_class->get_property = sai_thrift_object_list_t_get_property;
  gobject_class->set_property = sai_thrift_object_list_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_OBJECT_LIST_T_COUNT,
     g_param_spec_int ("count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_OBJECT_LIST_T_OBJECT_ID_LIST,
     g_param_spec_boxed ("object_id_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_object_list_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_object_list_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_object_list_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_object_list_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_object_list_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_object_list_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_vlan_list_tProperties
{
  PROP_SAI_THRIFT_VLAN_LIST_T_0,
  PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_COUNT,
  PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_LIST
};

/* reads a sai_thrift_vlan_list_t object */
static gint32
sai_thrift_vlan_list_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_vlan_list_t * this_object = SAI_THRIFT_VLAN_LIST_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->vlan_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vlan_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint16* _elem2 = g_new (gint16, 1);
              if ((ret = thrift_protocol_read_i16 (protocol, &*_elem2, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->vlan_list, _elem2, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_vlan_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_vlan_list_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_vlan_list_t * this_object = SAI_THRIFT_VLAN_LIST_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_vlan_list_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_count", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->vlan_count, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_list", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I16, (gint32) this_object->vlan_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < this_object->vlan_list->len; i3++)
    {
      if ((ret = thrift_protocol_write_i16 (protocol, (g_array_index (this_object->vlan_list, gint16, i3)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_vlan_list_t_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_vlan_list_t *self = SAI_THRIFT_VLAN_LIST_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_COUNT:
      self->vlan_count = g_value_get_int (value);
      self->__isset_vlan_count = TRUE;
      break;

    case PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_LIST:
      if (self->vlan_list != NULL)
        g_array_unref (self->vlan_list);
      self->vlan_list = g_value_dup_boxed (value);
      self->__isset_vlan_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_vlan_list_t_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_vlan_list_t *self = SAI_THRIFT_VLAN_LIST_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_COUNT:
      g_value_set_int (value, self->vlan_count);
      break;

    case PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_LIST:
      g_value_set_boxed (value, self->vlan_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_vlan_list_t_instance_init (sai_thrift_vlan_list_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vlan_count = 0;
  object->__isset_vlan_count = FALSE;
  object->vlan_list = g_array_new (0, 1, sizeof (gint16));
  object->__isset_vlan_list = FALSE;
}

static void 
sai_thrift_vlan_list_t_finalize (GObject *object)
{
  sai_thrift_vlan_list_t *tobject = SAI_THRIFT_VLAN_LIST_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->vlan_list != NULL)
  {
    g_array_unref (tobject->vlan_list);
    tobject->vlan_list = NULL;
  }
}

static void
sai_thrift_vlan_list_t_class_init (sai_thrift_vlan_list_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_vlan_list_t_read;
  struct_class->write = sai_thrift_vlan_list_t_write;

  gobject_class->finalize = sai_thrift_vlan_list_t_finalize;
  gobject_class->get_property = sai_thrift_vlan_list_t_get_property;
  gobject_class->set_property = sai_thrift_vlan_list_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_COUNT,
     g_param_spec_int ("vlan_count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_VLAN_LIST_T_VLAN_LIST,
     g_param_spec_boxed ("vlan_list",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_vlan_list_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_vlan_list_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_vlan_list_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_vlan_list_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_vlan_list_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_vlan_list_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_acl_mask_tProperties
{
  PROP_SAI_THRIFT_ACL_MASK_T_0,
  PROP_SAI_THRIFT_ACL_MASK_T_U8,
  PROP_SAI_THRIFT_ACL_MASK_T_S8,
  PROP_SAI_THRIFT_ACL_MASK_T_U16,
  PROP_SAI_THRIFT_ACL_MASK_T_S16,
  PROP_SAI_THRIFT_ACL_MASK_T_U32,
  PROP_SAI_THRIFT_ACL_MASK_T_S32,
  PROP_SAI_THRIFT_ACL_MASK_T_MAC,
  PROP_SAI_THRIFT_ACL_MASK_T_IP4,
  PROP_SAI_THRIFT_ACL_MASK_T_IP6
};

/* reads a sai_thrift_acl_mask_t object */
static gint32
sai_thrift_acl_mask_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_acl_mask_t * this_object = SAI_THRIFT_ACL_MASK_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->u8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->s8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->u16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->s16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->u32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->s32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->mac != NULL)
          {
            g_free(this_object->mac);
            this_object->mac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->ip4 != NULL)
          {
            g_free(this_object->ip4);
            this_object->ip4 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->ip6 != NULL)
          {
            g_free(this_object->ip6);
            this_object->ip6 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_acl_mask_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_acl_mask_t * this_object = SAI_THRIFT_ACL_MASK_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_acl_mask_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u8", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->u8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s8", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->s8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u16", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->u16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s16", T_I16, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->s16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u32", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->u32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s32", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->s32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mac", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->mac, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip4", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip4, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip6", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip6, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_acl_mask_t_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  sai_thrift_acl_mask_t *self = SAI_THRIFT_ACL_MASK_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_MASK_T_U8:
      self->u8 = g_value_get_int (value);
      self->__isset_u8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_S8:
      self->s8 = g_value_get_int (value);
      self->__isset_s8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_U16:
      self->u16 = g_value_get_int (value);
      self->__isset_u16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_S16:
      self->s16 = g_value_get_int (value);
      self->__isset_s16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_U32:
      self->u32 = g_value_get_int (value);
      self->__isset_u32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_S32:
      self->s32 = g_value_get_int (value);
      self->__isset_s32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_MAC:
      if (self->mac != NULL)
        g_free (self->mac);
      self->mac = g_value_dup_string (value);
      self->__isset_mac = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_IP4:
      if (self->ip4 != NULL)
        g_free (self->ip4);
      self->ip4 = g_value_dup_string (value);
      self->__isset_ip4 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_IP6:
      if (self->ip6 != NULL)
        g_free (self->ip6);
      self->ip6 = g_value_dup_string (value);
      self->__isset_ip6 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_acl_mask_t_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  sai_thrift_acl_mask_t *self = SAI_THRIFT_ACL_MASK_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_MASK_T_U8:
      g_value_set_int (value, self->u8);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_S8:
      g_value_set_int (value, self->s8);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_U16:
      g_value_set_int (value, self->u16);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_S16:
      g_value_set_int (value, self->s16);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_U32:
      g_value_set_int (value, self->u32);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_S32:
      g_value_set_int (value, self->s32);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_MAC:
      g_value_set_string (value, self->mac);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_IP4:
      g_value_set_string (value, self->ip4);
      break;

    case PROP_SAI_THRIFT_ACL_MASK_T_IP6:
      g_value_set_string (value, self->ip6);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_acl_mask_t_instance_init (sai_thrift_acl_mask_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->u8 = 0;
  object->__isset_u8 = FALSE;
  object->s8 = 0;
  object->__isset_s8 = FALSE;
  object->u16 = 0;
  object->__isset_u16 = FALSE;
  object->s16 = 0;
  object->__isset_s16 = FALSE;
  object->u32 = 0;
  object->__isset_u32 = FALSE;
  object->s32 = 0;
  object->__isset_s32 = FALSE;
  object->mac = NULL;
  object->__isset_mac = FALSE;
  object->ip4 = NULL;
  object->__isset_ip4 = FALSE;
  object->ip6 = NULL;
  object->__isset_ip6 = FALSE;
}

static void 
sai_thrift_acl_mask_t_finalize (GObject *object)
{
  sai_thrift_acl_mask_t *tobject = SAI_THRIFT_ACL_MASK_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mac != NULL)
  {
    g_free(tobject->mac);
    tobject->mac = NULL;
  }
  if (tobject->ip4 != NULL)
  {
    g_free(tobject->ip4);
    tobject->ip4 = NULL;
  }
  if (tobject->ip6 != NULL)
  {
    g_free(tobject->ip6);
    tobject->ip6 = NULL;
  }
}

static void
sai_thrift_acl_mask_t_class_init (sai_thrift_acl_mask_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_acl_mask_t_read;
  struct_class->write = sai_thrift_acl_mask_t_write;

  gobject_class->finalize = sai_thrift_acl_mask_t_finalize;
  gobject_class->get_property = sai_thrift_acl_mask_t_get_property;
  gobject_class->set_property = sai_thrift_acl_mask_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_U8,
     g_param_spec_int ("u8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_S8,
     g_param_spec_int ("s8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_U16,
     g_param_spec_int ("u16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_S16,
     g_param_spec_int ("s16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_U32,
     g_param_spec_int ("u32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_S32,
     g_param_spec_int ("s32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_MAC,
     g_param_spec_string ("mac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_IP4,
     g_param_spec_string ("ip4",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_MASK_T_IP6,
     g_param_spec_string ("ip6",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
sai_thrift_acl_mask_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_acl_mask_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_acl_mask_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_acl_mask_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_acl_mask_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_acl_mask_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_acl_data_tProperties
{
  PROP_SAI_THRIFT_ACL_DATA_T_0,
  PROP_SAI_THRIFT_ACL_DATA_T_U8,
  PROP_SAI_THRIFT_ACL_DATA_T_S8,
  PROP_SAI_THRIFT_ACL_DATA_T_U16,
  PROP_SAI_THRIFT_ACL_DATA_T_S16,
  PROP_SAI_THRIFT_ACL_DATA_T_U32,
  PROP_SAI_THRIFT_ACL_DATA_T_S32,
  PROP_SAI_THRIFT_ACL_DATA_T_MAC,
  PROP_SAI_THRIFT_ACL_DATA_T_IP4,
  PROP_SAI_THRIFT_ACL_DATA_T_IP6,
  PROP_SAI_THRIFT_ACL_DATA_T_OID,
  PROP_SAI_THRIFT_ACL_DATA_T_OBJLIST
};

/* reads a sai_thrift_acl_data_t object */
static gint32
sai_thrift_acl_data_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_acl_data_t * this_object = SAI_THRIFT_ACL_DATA_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->u8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->s8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->u16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->s16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->u32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->s32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->mac != NULL)
          {
            g_free(this_object->mac);
            this_object->mac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->ip4 != NULL)
          {
            g_free(this_object->ip4);
            this_object->ip4 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->ip6 != NULL)
          {
            g_free(this_object->ip6);
            this_object->ip6 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->oid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_oid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->objlist), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_objlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_acl_data_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_acl_data_t * this_object = SAI_THRIFT_ACL_DATA_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_acl_data_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u8", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->u8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s8", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->s8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u16", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->u16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s16", T_I16, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->s16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u32", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->u32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s32", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->s32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mac", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->mac, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip4", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip4, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip6", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip6, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "oid", T_I64, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->oid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "objlist", T_STRUCT, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->objlist), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_acl_data_t_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  sai_thrift_acl_data_t *self = SAI_THRIFT_ACL_DATA_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_DATA_T_U8:
      self->u8 = g_value_get_int (value);
      self->__isset_u8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_S8:
      self->s8 = g_value_get_int (value);
      self->__isset_s8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_U16:
      self->u16 = g_value_get_int (value);
      self->__isset_u16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_S16:
      self->s16 = g_value_get_int (value);
      self->__isset_s16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_U32:
      self->u32 = g_value_get_int (value);
      self->__isset_u32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_S32:
      self->s32 = g_value_get_int (value);
      self->__isset_s32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_MAC:
      if (self->mac != NULL)
        g_free (self->mac);
      self->mac = g_value_dup_string (value);
      self->__isset_mac = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_IP4:
      if (self->ip4 != NULL)
        g_free (self->ip4);
      self->ip4 = g_value_dup_string (value);
      self->__isset_ip4 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_IP6:
      if (self->ip6 != NULL)
        g_free (self->ip6);
      self->ip6 = g_value_dup_string (value);
      self->__isset_ip6 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_OID:
      self->oid = g_value_get_int64 (value);
      self->__isset_oid = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_OBJLIST:
      if (self->objlist != NULL)
        g_object_unref (self->objlist);
      self->objlist = g_value_dup_object (value);
      self->__isset_objlist = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_acl_data_t_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  sai_thrift_acl_data_t *self = SAI_THRIFT_ACL_DATA_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_DATA_T_U8:
      g_value_set_int (value, self->u8);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_S8:
      g_value_set_int (value, self->s8);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_U16:
      g_value_set_int (value, self->u16);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_S16:
      g_value_set_int (value, self->s16);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_U32:
      g_value_set_int (value, self->u32);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_S32:
      g_value_set_int (value, self->s32);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_MAC:
      g_value_set_string (value, self->mac);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_IP4:
      g_value_set_string (value, self->ip4);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_IP6:
      g_value_set_string (value, self->ip6);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_OID:
      g_value_set_int64 (value, self->oid);
      break;

    case PROP_SAI_THRIFT_ACL_DATA_T_OBJLIST:
      g_value_set_object (value, self->objlist);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_acl_data_t_instance_init (sai_thrift_acl_data_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->u8 = 0;
  object->__isset_u8 = FALSE;
  object->s8 = 0;
  object->__isset_s8 = FALSE;
  object->u16 = 0;
  object->__isset_u16 = FALSE;
  object->s16 = 0;
  object->__isset_s16 = FALSE;
  object->u32 = 0;
  object->__isset_u32 = FALSE;
  object->s32 = 0;
  object->__isset_s32 = FALSE;
  object->mac = NULL;
  object->__isset_mac = FALSE;
  object->ip4 = NULL;
  object->__isset_ip4 = FALSE;
  object->ip6 = NULL;
  object->__isset_ip6 = FALSE;
  object->oid = 0;
  object->__isset_oid = FALSE;
  object->objlist = g_object_new (TYPE_SAI_THRIFT_OBJECT_LIST_T, NULL);
  object->__isset_objlist = FALSE;
}

static void 
sai_thrift_acl_data_t_finalize (GObject *object)
{
  sai_thrift_acl_data_t *tobject = SAI_THRIFT_ACL_DATA_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mac != NULL)
  {
    g_free(tobject->mac);
    tobject->mac = NULL;
  }
  if (tobject->ip4 != NULL)
  {
    g_free(tobject->ip4);
    tobject->ip4 = NULL;
  }
  if (tobject->ip6 != NULL)
  {
    g_free(tobject->ip6);
    tobject->ip6 = NULL;
  }
  if (tobject->objlist != NULL)
  {
    g_object_unref(tobject->objlist);
    tobject->objlist = NULL;
  }
}

static void
sai_thrift_acl_data_t_class_init (sai_thrift_acl_data_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_acl_data_t_read;
  struct_class->write = sai_thrift_acl_data_t_write;

  gobject_class->finalize = sai_thrift_acl_data_t_finalize;
  gobject_class->get_property = sai_thrift_acl_data_t_get_property;
  gobject_class->set_property = sai_thrift_acl_data_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_U8,
     g_param_spec_int ("u8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_S8,
     g_param_spec_int ("s8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_U16,
     g_param_spec_int ("u16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_S16,
     g_param_spec_int ("s16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_U32,
     g_param_spec_int ("u32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_S32,
     g_param_spec_int ("s32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_MAC,
     g_param_spec_string ("mac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_IP4,
     g_param_spec_string ("ip4",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_IP6,
     g_param_spec_string ("ip6",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_OID,
     g_param_spec_int64 ("oid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_DATA_T_OBJLIST,
     g_param_spec_object ("objlist",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_OBJECT_LIST_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_acl_data_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_acl_data_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_acl_data_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_acl_data_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_acl_data_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_acl_data_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_acl_field_data_tProperties
{
  PROP_SAI_THRIFT_ACL_FIELD_DATA_T_0,
  PROP_SAI_THRIFT_ACL_FIELD_DATA_T_ENABLE,
  PROP_SAI_THRIFT_ACL_FIELD_DATA_T_MASK,
  PROP_SAI_THRIFT_ACL_FIELD_DATA_T_DATA
};

/* reads a sai_thrift_acl_field_data_t object */
static gint32
sai_thrift_acl_field_data_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_acl_field_data_t * this_object = SAI_THRIFT_ACL_FIELD_DATA_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enable, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enable = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->mask), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_mask = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_acl_field_data_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_acl_field_data_t * this_object = SAI_THRIFT_ACL_FIELD_DATA_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_acl_field_data_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "enable", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->enable, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mask", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->mask), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "data", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_acl_field_data_t_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  sai_thrift_acl_field_data_t *self = SAI_THRIFT_ACL_FIELD_DATA_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_FIELD_DATA_T_ENABLE:
      self->enable = g_value_get_boolean (value);
      self->__isset_enable = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_FIELD_DATA_T_MASK:
      if (self->mask != NULL)
        g_object_unref (self->mask);
      self->mask = g_value_dup_object (value);
      self->__isset_mask = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_FIELD_DATA_T_DATA:
      if (self->data != NULL)
        g_object_unref (self->data);
      self->data = g_value_dup_object (value);
      self->__isset_data = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_acl_field_data_t_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  sai_thrift_acl_field_data_t *self = SAI_THRIFT_ACL_FIELD_DATA_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_FIELD_DATA_T_ENABLE:
      g_value_set_boolean (value, self->enable);
      break;

    case PROP_SAI_THRIFT_ACL_FIELD_DATA_T_MASK:
      g_value_set_object (value, self->mask);
      break;

    case PROP_SAI_THRIFT_ACL_FIELD_DATA_T_DATA:
      g_value_set_object (value, self->data);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_acl_field_data_t_instance_init (sai_thrift_acl_field_data_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->enable = 0;
  object->__isset_enable = FALSE;
  object->mask = g_object_new (TYPE_SAI_THRIFT_ACL_MASK_T, NULL);
  object->__isset_mask = FALSE;
  object->data = g_object_new (TYPE_SAI_THRIFT_ACL_DATA_T, NULL);
  object->__isset_data = FALSE;
}

static void 
sai_thrift_acl_field_data_t_finalize (GObject *object)
{
  sai_thrift_acl_field_data_t *tobject = SAI_THRIFT_ACL_FIELD_DATA_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mask != NULL)
  {
    g_object_unref(tobject->mask);
    tobject->mask = NULL;
  }
  if (tobject->data != NULL)
  {
    g_object_unref(tobject->data);
    tobject->data = NULL;
  }
}

static void
sai_thrift_acl_field_data_t_class_init (sai_thrift_acl_field_data_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_acl_field_data_t_read;
  struct_class->write = sai_thrift_acl_field_data_t_write;

  gobject_class->finalize = sai_thrift_acl_field_data_t_finalize;
  gobject_class->get_property = sai_thrift_acl_field_data_t_get_property;
  gobject_class->set_property = sai_thrift_acl_field_data_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_FIELD_DATA_T_ENABLE,
     g_param_spec_boolean ("enable",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_FIELD_DATA_T_MASK,
     g_param_spec_object ("mask",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ACL_MASK_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_FIELD_DATA_T_DATA,
     g_param_spec_object ("data",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ACL_DATA_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_acl_field_data_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_acl_field_data_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_acl_field_data_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_acl_field_data_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_acl_field_data_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_acl_field_data_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_acl_parameter_tProperties
{
  PROP_SAI_THRIFT_ACL_PARAMETER_T_0,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_U8,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_S8,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_U16,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_S16,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_U32,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_S32,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_MAC,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_IP4,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_IP6,
  PROP_SAI_THRIFT_ACL_PARAMETER_T_OID
};

/* reads a sai_thrift_acl_parameter_t object */
static gint32
sai_thrift_acl_parameter_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_acl_parameter_t * this_object = SAI_THRIFT_ACL_PARAMETER_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->u8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->s8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->u16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->s16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->u32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->s32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->mac != NULL)
          {
            g_free(this_object->mac);
            this_object->mac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->ip4 != NULL)
          {
            g_free(this_object->ip4);
            this_object->ip4 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->ip6 != NULL)
          {
            g_free(this_object->ip6);
            this_object->ip6 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->oid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_oid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_acl_parameter_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_acl_parameter_t * this_object = SAI_THRIFT_ACL_PARAMETER_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_acl_parameter_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u8", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->u8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s8", T_BYTE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->s8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u16", T_I16, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->u16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s16", T_I16, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->s16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u32", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->u32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s32", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->s32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mac", T_STRING, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->mac, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip4", T_STRING, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip4, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip6", T_STRING, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip6, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "oid", T_I64, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->oid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_acl_parameter_t_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  sai_thrift_acl_parameter_t *self = SAI_THRIFT_ACL_PARAMETER_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_PARAMETER_T_U8:
      self->u8 = g_value_get_int (value);
      self->__isset_u8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_S8:
      self->s8 = g_value_get_int (value);
      self->__isset_s8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_U16:
      self->u16 = g_value_get_int (value);
      self->__isset_u16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_S16:
      self->s16 = g_value_get_int (value);
      self->__isset_s16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_U32:
      self->u32 = g_value_get_int (value);
      self->__isset_u32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_S32:
      self->s32 = g_value_get_int (value);
      self->__isset_s32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_MAC:
      if (self->mac != NULL)
        g_free (self->mac);
      self->mac = g_value_dup_string (value);
      self->__isset_mac = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_IP4:
      if (self->ip4 != NULL)
        g_free (self->ip4);
      self->ip4 = g_value_dup_string (value);
      self->__isset_ip4 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_IP6:
      if (self->ip6 != NULL)
        g_free (self->ip6);
      self->ip6 = g_value_dup_string (value);
      self->__isset_ip6 = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_OID:
      self->oid = g_value_get_int64 (value);
      self->__isset_oid = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_acl_parameter_t_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  sai_thrift_acl_parameter_t *self = SAI_THRIFT_ACL_PARAMETER_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_PARAMETER_T_U8:
      g_value_set_int (value, self->u8);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_S8:
      g_value_set_int (value, self->s8);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_U16:
      g_value_set_int (value, self->u16);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_S16:
      g_value_set_int (value, self->s16);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_U32:
      g_value_set_int (value, self->u32);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_S32:
      g_value_set_int (value, self->s32);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_MAC:
      g_value_set_string (value, self->mac);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_IP4:
      g_value_set_string (value, self->ip4);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_IP6:
      g_value_set_string (value, self->ip6);
      break;

    case PROP_SAI_THRIFT_ACL_PARAMETER_T_OID:
      g_value_set_int64 (value, self->oid);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_acl_parameter_t_instance_init (sai_thrift_acl_parameter_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->u8 = 0;
  object->__isset_u8 = FALSE;
  object->s8 = 0;
  object->__isset_s8 = FALSE;
  object->u16 = 0;
  object->__isset_u16 = FALSE;
  object->s16 = 0;
  object->__isset_s16 = FALSE;
  object->u32 = 0;
  object->__isset_u32 = FALSE;
  object->s32 = 0;
  object->__isset_s32 = FALSE;
  object->mac = NULL;
  object->__isset_mac = FALSE;
  object->ip4 = NULL;
  object->__isset_ip4 = FALSE;
  object->ip6 = NULL;
  object->__isset_ip6 = FALSE;
  object->oid = 0;
  object->__isset_oid = FALSE;
}

static void 
sai_thrift_acl_parameter_t_finalize (GObject *object)
{
  sai_thrift_acl_parameter_t *tobject = SAI_THRIFT_ACL_PARAMETER_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->mac != NULL)
  {
    g_free(tobject->mac);
    tobject->mac = NULL;
  }
  if (tobject->ip4 != NULL)
  {
    g_free(tobject->ip4);
    tobject->ip4 = NULL;
  }
  if (tobject->ip6 != NULL)
  {
    g_free(tobject->ip6);
    tobject->ip6 = NULL;
  }
}

static void
sai_thrift_acl_parameter_t_class_init (sai_thrift_acl_parameter_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_acl_parameter_t_read;
  struct_class->write = sai_thrift_acl_parameter_t_write;

  gobject_class->finalize = sai_thrift_acl_parameter_t_finalize;
  gobject_class->get_property = sai_thrift_acl_parameter_t_get_property;
  gobject_class->set_property = sai_thrift_acl_parameter_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_U8,
     g_param_spec_int ("u8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_S8,
     g_param_spec_int ("s8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_U16,
     g_param_spec_int ("u16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_S16,
     g_param_spec_int ("s16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_U32,
     g_param_spec_int ("u32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_S32,
     g_param_spec_int ("s32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_MAC,
     g_param_spec_string ("mac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_IP4,
     g_param_spec_string ("ip4",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_IP6,
     g_param_spec_string ("ip6",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_PARAMETER_T_OID,
     g_param_spec_int64 ("oid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_acl_parameter_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_acl_parameter_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_acl_parameter_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_acl_parameter_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_acl_parameter_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_acl_parameter_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_acl_action_data_tProperties
{
  PROP_SAI_THRIFT_ACL_ACTION_DATA_T_0,
  PROP_SAI_THRIFT_ACL_ACTION_DATA_T_ENABLE,
  PROP_SAI_THRIFT_ACL_ACTION_DATA_T_PARAMETER
};

/* reads a sai_thrift_acl_action_data_t object */
static gint32
sai_thrift_acl_action_data_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_acl_action_data_t * this_object = SAI_THRIFT_ACL_ACTION_DATA_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->enable, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_enable = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->parameter), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_parameter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_acl_action_data_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_acl_action_data_t * this_object = SAI_THRIFT_ACL_ACTION_DATA_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_acl_action_data_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "enable", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->enable, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "parameter", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->parameter), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_acl_action_data_t_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  sai_thrift_acl_action_data_t *self = SAI_THRIFT_ACL_ACTION_DATA_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_ACTION_DATA_T_ENABLE:
      self->enable = g_value_get_boolean (value);
      self->__isset_enable = TRUE;
      break;

    case PROP_SAI_THRIFT_ACL_ACTION_DATA_T_PARAMETER:
      if (self->parameter != NULL)
        g_object_unref (self->parameter);
      self->parameter = g_value_dup_object (value);
      self->__isset_parameter = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_acl_action_data_t_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  sai_thrift_acl_action_data_t *self = SAI_THRIFT_ACL_ACTION_DATA_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ACL_ACTION_DATA_T_ENABLE:
      g_value_set_boolean (value, self->enable);
      break;

    case PROP_SAI_THRIFT_ACL_ACTION_DATA_T_PARAMETER:
      g_value_set_object (value, self->parameter);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_acl_action_data_t_instance_init (sai_thrift_acl_action_data_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->enable = 0;
  object->__isset_enable = FALSE;
  object->parameter = g_object_new (TYPE_SAI_THRIFT_ACL_PARAMETER_T, NULL);
  object->__isset_parameter = FALSE;
}

static void 
sai_thrift_acl_action_data_t_finalize (GObject *object)
{
  sai_thrift_acl_action_data_t *tobject = SAI_THRIFT_ACL_ACTION_DATA_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->parameter != NULL)
  {
    g_object_unref(tobject->parameter);
    tobject->parameter = NULL;
  }
}

static void
sai_thrift_acl_action_data_t_class_init (sai_thrift_acl_action_data_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_acl_action_data_t_read;
  struct_class->write = sai_thrift_acl_action_data_t_write;

  gobject_class->finalize = sai_thrift_acl_action_data_t_finalize;
  gobject_class->get_property = sai_thrift_acl_action_data_t_get_property;
  gobject_class->set_property = sai_thrift_acl_action_data_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_ACTION_DATA_T_ENABLE,
     g_param_spec_boolean ("enable",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ACL_ACTION_DATA_T_PARAMETER,
     g_param_spec_object ("parameter",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ACL_PARAMETER_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_acl_action_data_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_acl_action_data_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_acl_action_data_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_acl_action_data_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_acl_action_data_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_acl_action_data_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_attribute_value_tProperties
{
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_0,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_BOOLDATA,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_CHARDATA,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U8,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S8,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U16,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S16,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U32,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S32,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U64,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S64,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_MAC,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OID,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP4,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP6,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IPADDR,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OBJLIST,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_VLANLIST,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLFIELD,
  PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLACTION
};

/* reads a sai_thrift_attribute_value_t object */
static gint32
sai_thrift_attribute_value_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_attribute_value_t * this_object = SAI_THRIFT_ATTRIBUTE_VALUE_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->booldata, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_booldata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->chardata != NULL)
          {
            g_free(this_object->chardata);
            this_object->chardata = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->chardata, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_chardata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->u8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->s8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s8 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->u16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->s16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->u32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->s32, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s32 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->u64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_u64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->s64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_s64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->mac != NULL)
          {
            g_free(this_object->mac);
            this_object->mac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->oid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_oid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_STRING)
        {
          if (this_object->ip4 != NULL)
          {
            g_free(this_object->ip4);
            this_object->ip4 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip4, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_STRING)
        {
          if (this_object->ip6 != NULL)
          {
            g_free(this_object->ip6);
            this_object->ip6 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ip6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ip6 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ipaddr), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ipaddr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->objlist), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_objlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->vlanlist), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_vlanlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->aclfield), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_aclfield = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 19:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->aclaction), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_aclaction = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_attribute_value_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_attribute_value_t * this_object = SAI_THRIFT_ATTRIBUTE_VALUE_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_attribute_value_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "booldata", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->booldata, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "chardata", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->chardata, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u8", T_BYTE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->u8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s8", T_BYTE, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->s8, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u16", T_I16, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->u16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s16", T_I16, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->s16, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u32", T_I32, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->u32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s32", T_I32, 8, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->s32, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "u64", T_I64, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->u64, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "s64", T_I64, 10, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->s64, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "mac", T_STRING, 11, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->mac, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "oid", T_I64, 12, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->oid, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip4", T_STRING, 13, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip4, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip6", T_STRING, 14, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ip6, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ipaddr", T_STRUCT, 15, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ipaddr), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "objlist", T_STRUCT, 16, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->objlist), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlanlist", T_STRUCT, 17, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->vlanlist), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aclfield", T_STRUCT, 18, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->aclfield), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "aclaction", T_STRUCT, 19, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->aclaction), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_attribute_value_t_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  sai_thrift_attribute_value_t *self = SAI_THRIFT_ATTRIBUTE_VALUE_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_BOOLDATA:
      self->booldata = g_value_get_boolean (value);
      self->__isset_booldata = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_CHARDATA:
      if (self->chardata != NULL)
        g_free (self->chardata);
      self->chardata = g_value_dup_string (value);
      self->__isset_chardata = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U8:
      self->u8 = g_value_get_int (value);
      self->__isset_u8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S8:
      self->s8 = g_value_get_int (value);
      self->__isset_s8 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U16:
      self->u16 = g_value_get_int (value);
      self->__isset_u16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S16:
      self->s16 = g_value_get_int (value);
      self->__isset_s16 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U32:
      self->u32 = g_value_get_int (value);
      self->__isset_u32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S32:
      self->s32 = g_value_get_int (value);
      self->__isset_s32 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U64:
      self->u64 = g_value_get_int64 (value);
      self->__isset_u64 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S64:
      self->s64 = g_value_get_int64 (value);
      self->__isset_s64 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_MAC:
      if (self->mac != NULL)
        g_free (self->mac);
      self->mac = g_value_dup_string (value);
      self->__isset_mac = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OID:
      self->oid = g_value_get_int64 (value);
      self->__isset_oid = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP4:
      if (self->ip4 != NULL)
        g_free (self->ip4);
      self->ip4 = g_value_dup_string (value);
      self->__isset_ip4 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP6:
      if (self->ip6 != NULL)
        g_free (self->ip6);
      self->ip6 = g_value_dup_string (value);
      self->__isset_ip6 = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IPADDR:
      if (self->ipaddr != NULL)
        g_object_unref (self->ipaddr);
      self->ipaddr = g_value_dup_object (value);
      self->__isset_ipaddr = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OBJLIST:
      if (self->objlist != NULL)
        g_object_unref (self->objlist);
      self->objlist = g_value_dup_object (value);
      self->__isset_objlist = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_VLANLIST:
      if (self->vlanlist != NULL)
        g_object_unref (self->vlanlist);
      self->vlanlist = g_value_dup_object (value);
      self->__isset_vlanlist = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLFIELD:
      if (self->aclfield != NULL)
        g_object_unref (self->aclfield);
      self->aclfield = g_value_dup_object (value);
      self->__isset_aclfield = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLACTION:
      if (self->aclaction != NULL)
        g_object_unref (self->aclaction);
      self->aclaction = g_value_dup_object (value);
      self->__isset_aclaction = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_attribute_value_t_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  sai_thrift_attribute_value_t *self = SAI_THRIFT_ATTRIBUTE_VALUE_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_BOOLDATA:
      g_value_set_boolean (value, self->booldata);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_CHARDATA:
      g_value_set_string (value, self->chardata);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U8:
      g_value_set_int (value, self->u8);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S8:
      g_value_set_int (value, self->s8);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U16:
      g_value_set_int (value, self->u16);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S16:
      g_value_set_int (value, self->s16);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U32:
      g_value_set_int (value, self->u32);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S32:
      g_value_set_int (value, self->s32);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U64:
      g_value_set_int64 (value, self->u64);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S64:
      g_value_set_int64 (value, self->s64);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_MAC:
      g_value_set_string (value, self->mac);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OID:
      g_value_set_int64 (value, self->oid);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP4:
      g_value_set_string (value, self->ip4);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP6:
      g_value_set_string (value, self->ip6);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IPADDR:
      g_value_set_object (value, self->ipaddr);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OBJLIST:
      g_value_set_object (value, self->objlist);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_VLANLIST:
      g_value_set_object (value, self->vlanlist);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLFIELD:
      g_value_set_object (value, self->aclfield);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLACTION:
      g_value_set_object (value, self->aclaction);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_attribute_value_t_instance_init (sai_thrift_attribute_value_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->booldata = 0;
  object->__isset_booldata = FALSE;
  object->chardata = NULL;
  object->__isset_chardata = FALSE;
  object->u8 = 0;
  object->__isset_u8 = FALSE;
  object->s8 = 0;
  object->__isset_s8 = FALSE;
  object->u16 = 0;
  object->__isset_u16 = FALSE;
  object->s16 = 0;
  object->__isset_s16 = FALSE;
  object->u32 = 0;
  object->__isset_u32 = FALSE;
  object->s32 = 0;
  object->__isset_s32 = FALSE;
  object->u64 = 0;
  object->__isset_u64 = FALSE;
  object->s64 = 0;
  object->__isset_s64 = FALSE;
  object->mac = NULL;
  object->__isset_mac = FALSE;
  object->oid = 0;
  object->__isset_oid = FALSE;
  object->ip4 = NULL;
  object->__isset_ip4 = FALSE;
  object->ip6 = NULL;
  object->__isset_ip6 = FALSE;
  object->ipaddr = g_object_new (TYPE_SAI_THRIFT_IP_ADDRESS_T, NULL);
  object->__isset_ipaddr = FALSE;
  object->objlist = g_object_new (TYPE_SAI_THRIFT_OBJECT_LIST_T, NULL);
  object->__isset_objlist = FALSE;
  object->vlanlist = g_object_new (TYPE_SAI_THRIFT_VLAN_LIST_T, NULL);
  object->__isset_vlanlist = FALSE;
  object->aclfield = g_object_new (TYPE_SAI_THRIFT_ACL_FIELD_DATA_T, NULL);
  object->__isset_aclfield = FALSE;
  object->aclaction = g_object_new (TYPE_SAI_THRIFT_ACL_ACTION_DATA_T, NULL);
  object->__isset_aclaction = FALSE;
}

static void 
sai_thrift_attribute_value_t_finalize (GObject *object)
{
  sai_thrift_attribute_value_t *tobject = SAI_THRIFT_ATTRIBUTE_VALUE_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->chardata != NULL)
  {
    g_free(tobject->chardata);
    tobject->chardata = NULL;
  }
  if (tobject->mac != NULL)
  {
    g_free(tobject->mac);
    tobject->mac = NULL;
  }
  if (tobject->ip4 != NULL)
  {
    g_free(tobject->ip4);
    tobject->ip4 = NULL;
  }
  if (tobject->ip6 != NULL)
  {
    g_free(tobject->ip6);
    tobject->ip6 = NULL;
  }
  if (tobject->ipaddr != NULL)
  {
    g_object_unref(tobject->ipaddr);
    tobject->ipaddr = NULL;
  }
  if (tobject->objlist != NULL)
  {
    g_object_unref(tobject->objlist);
    tobject->objlist = NULL;
  }
  if (tobject->vlanlist != NULL)
  {
    g_object_unref(tobject->vlanlist);
    tobject->vlanlist = NULL;
  }
  if (tobject->aclfield != NULL)
  {
    g_object_unref(tobject->aclfield);
    tobject->aclfield = NULL;
  }
  if (tobject->aclaction != NULL)
  {
    g_object_unref(tobject->aclaction);
    tobject->aclaction = NULL;
  }
}

static void
sai_thrift_attribute_value_t_class_init (sai_thrift_attribute_value_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_attribute_value_t_read;
  struct_class->write = sai_thrift_attribute_value_t_write;

  gobject_class->finalize = sai_thrift_attribute_value_t_finalize;
  gobject_class->get_property = sai_thrift_attribute_value_t_get_property;
  gobject_class->set_property = sai_thrift_attribute_value_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_BOOLDATA,
     g_param_spec_boolean ("booldata",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_CHARDATA,
     g_param_spec_string ("chardata",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U8,
     g_param_spec_int ("u8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S8,
     g_param_spec_int ("s8",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U16,
     g_param_spec_int ("u16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S16,
     g_param_spec_int ("s16",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U32,
     g_param_spec_int ("u32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S32,
     g_param_spec_int ("s32",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_U64,
     g_param_spec_int64 ("u64",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_S64,
     g_param_spec_int64 ("s64",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_MAC,
     g_param_spec_string ("mac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OID,
     g_param_spec_int64 ("oid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP4,
     g_param_spec_string ("ip4",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IP6,
     g_param_spec_string ("ip6",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_IPADDR,
     g_param_spec_object ("ipaddr",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_IP_ADDRESS_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_OBJLIST,
     g_param_spec_object ("objlist",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_OBJECT_LIST_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_VLANLIST,
     g_param_spec_object ("vlanlist",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_VLAN_LIST_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLFIELD,
     g_param_spec_object ("aclfield",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ACL_FIELD_DATA_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_VALUE_T_ACLACTION,
     g_param_spec_object ("aclaction",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ACL_ACTION_DATA_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_attribute_value_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_attribute_value_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_attribute_value_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_attribute_value_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_attribute_value_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_attribute_value_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_attribute_tProperties
{
  PROP_SAI_THRIFT_ATTRIBUTE_T_0,
  PROP_SAI_THRIFT_ATTRIBUTE_T_ID,
  PROP_SAI_THRIFT_ATTRIBUTE_T_VALUE
};

/* reads a sai_thrift_attribute_t object */
static gint32
sai_thrift_attribute_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_attribute_t * this_object = SAI_THRIFT_ATTRIBUTE_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_attribute_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_attribute_t * this_object = SAI_THRIFT_ATTRIBUTE_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_attribute_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->value), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_attribute_t_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_attribute_t *self = SAI_THRIFT_ATTRIBUTE_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ATTRIBUTE_T_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_T_VALUE:
      if (self->value != NULL)
        g_object_unref (self->value);
      self->value = g_value_dup_object (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_attribute_t_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  sai_thrift_attribute_t *self = SAI_THRIFT_ATTRIBUTE_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ATTRIBUTE_T_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_T_VALUE:
      g_value_set_object (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_attribute_t_instance_init (sai_thrift_attribute_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
  object->value = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_VALUE_T, NULL);
  object->__isset_value = FALSE;
}

static void 
sai_thrift_attribute_t_finalize (GObject *object)
{
  sai_thrift_attribute_t *tobject = SAI_THRIFT_ATTRIBUTE_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_object_unref(tobject->value);
    tobject->value = NULL;
  }
}

static void
sai_thrift_attribute_t_class_init (sai_thrift_attribute_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_attribute_t_read;
  struct_class->write = sai_thrift_attribute_t_write;

  gobject_class->finalize = sai_thrift_attribute_t_finalize;
  gobject_class->get_property = sai_thrift_attribute_t_get_property;
  gobject_class->set_property = sai_thrift_attribute_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_T_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_T_VALUE,
     g_param_spec_object ("value",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ATTRIBUTE_VALUE_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_attribute_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_attribute_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_attribute_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_attribute_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_attribute_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_attribute_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_unicast_route_entry_tProperties
{
  PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_0,
  PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_VR_ID,
  PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_DESTINATION
};

/* reads a sai_thrift_unicast_route_entry_t object */
static gint32
sai_thrift_unicast_route_entry_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_unicast_route_entry_t * this_object = SAI_THRIFT_UNICAST_ROUTE_ENTRY_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->vr_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vr_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->destination), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_destination = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_unicast_route_entry_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_unicast_route_entry_t * this_object = SAI_THRIFT_UNICAST_ROUTE_ENTRY_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_unicast_route_entry_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vr_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->vr_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "destination", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->destination), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_unicast_route_entry_t_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  sai_thrift_unicast_route_entry_t *self = SAI_THRIFT_UNICAST_ROUTE_ENTRY_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_VR_ID:
      self->vr_id = g_value_get_int64 (value);
      self->__isset_vr_id = TRUE;
      break;

    case PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_DESTINATION:
      if (self->destination != NULL)
        g_object_unref (self->destination);
      self->destination = g_value_dup_object (value);
      self->__isset_destination = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_unicast_route_entry_t_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  sai_thrift_unicast_route_entry_t *self = SAI_THRIFT_UNICAST_ROUTE_ENTRY_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_VR_ID:
      g_value_set_int64 (value, self->vr_id);
      break;

    case PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_DESTINATION:
      g_value_set_object (value, self->destination);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_unicast_route_entry_t_instance_init (sai_thrift_unicast_route_entry_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vr_id = 0;
  object->__isset_vr_id = FALSE;
  object->destination = g_object_new (TYPE_SAI_THRIFT_IP_PREFIX_T, NULL);
  object->__isset_destination = FALSE;
}

static void 
sai_thrift_unicast_route_entry_t_finalize (GObject *object)
{
  sai_thrift_unicast_route_entry_t *tobject = SAI_THRIFT_UNICAST_ROUTE_ENTRY_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->destination != NULL)
  {
    g_object_unref(tobject->destination);
    tobject->destination = NULL;
  }
}

static void
sai_thrift_unicast_route_entry_t_class_init (sai_thrift_unicast_route_entry_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_unicast_route_entry_t_read;
  struct_class->write = sai_thrift_unicast_route_entry_t_write;

  gobject_class->finalize = sai_thrift_unicast_route_entry_t_finalize;
  gobject_class->get_property = sai_thrift_unicast_route_entry_t_get_property;
  gobject_class->set_property = sai_thrift_unicast_route_entry_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_VR_ID,
     g_param_spec_int64 ("vr_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T_DESTINATION,
     g_param_spec_object ("destination",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_IP_PREFIX_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_unicast_route_entry_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_unicast_route_entry_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_unicast_route_entry_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_unicast_route_entry_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_unicast_route_entry_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_unicast_route_entry_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_neighbor_entry_tProperties
{
  PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_0,
  PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_RIF_ID,
  PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_IP_ADDRESS
};

/* reads a sai_thrift_neighbor_entry_t object */
static gint32
sai_thrift_neighbor_entry_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_neighbor_entry_t * this_object = SAI_THRIFT_NEIGHBOR_ENTRY_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->rif_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rif_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ip_address), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ip_address = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_neighbor_entry_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_neighbor_entry_t * this_object = SAI_THRIFT_NEIGHBOR_ENTRY_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_neighbor_entry_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rif_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->rif_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ip_address", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ip_address), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_neighbor_entry_t_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  sai_thrift_neighbor_entry_t *self = SAI_THRIFT_NEIGHBOR_ENTRY_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_RIF_ID:
      self->rif_id = g_value_get_int64 (value);
      self->__isset_rif_id = TRUE;
      break;

    case PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_IP_ADDRESS:
      if (self->ip_address != NULL)
        g_object_unref (self->ip_address);
      self->ip_address = g_value_dup_object (value);
      self->__isset_ip_address = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_neighbor_entry_t_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  sai_thrift_neighbor_entry_t *self = SAI_THRIFT_NEIGHBOR_ENTRY_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_RIF_ID:
      g_value_set_int64 (value, self->rif_id);
      break;

    case PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_IP_ADDRESS:
      g_value_set_object (value, self->ip_address);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_neighbor_entry_t_instance_init (sai_thrift_neighbor_entry_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rif_id = 0;
  object->__isset_rif_id = FALSE;
  object->ip_address = g_object_new (TYPE_SAI_THRIFT_IP_ADDRESS_T, NULL);
  object->__isset_ip_address = FALSE;
}

static void 
sai_thrift_neighbor_entry_t_finalize (GObject *object)
{
  sai_thrift_neighbor_entry_t *tobject = SAI_THRIFT_NEIGHBOR_ENTRY_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ip_address != NULL)
  {
    g_object_unref(tobject->ip_address);
    tobject->ip_address = NULL;
  }
}

static void
sai_thrift_neighbor_entry_t_class_init (sai_thrift_neighbor_entry_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_neighbor_entry_t_read;
  struct_class->write = sai_thrift_neighbor_entry_t_write;

  gobject_class->finalize = sai_thrift_neighbor_entry_t_finalize;
  gobject_class->get_property = sai_thrift_neighbor_entry_t_get_property;
  gobject_class->set_property = sai_thrift_neighbor_entry_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_RIF_ID,
     g_param_spec_int64 ("rif_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_NEIGHBOR_ENTRY_T_IP_ADDRESS,
     g_param_spec_object ("ip_address",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_IP_ADDRESS_T,
                         G_PARAM_READWRITE));
}

GType
sai_thrift_neighbor_entry_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_neighbor_entry_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_neighbor_entry_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_neighbor_entry_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_neighbor_entry_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_neighbor_entry_tType",
                                   &type_info, 0);
  }

  return type;
}

enum _sai_thrift_attribute_list_tProperties
{
  PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_0,
  PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_LIST,
  PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_COUNT
};

/* reads a sai_thrift_attribute_list_t object */
static gint32
sai_thrift_attribute_list_t_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  sai_thrift_attribute_list_t * this_object = SAI_THRIFT_ATTRIBUTE_LIST_T(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem4 = NULL;
              if ( _elem4 != NULL)
              {
                g_object_unref (_elem4);
              }
              _elem4 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem4), protocol, error)) < 0)
              {
                g_object_unref (_elem4);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->attr_list, _elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->attr_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_attr_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
sai_thrift_attribute_list_t_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  sai_thrift_attribute_list_t * this_object = SAI_THRIFT_ATTRIBUTE_LIST_T(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "sai_thrift_attribute_list_t", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < this_object->attr_list->len; i5++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->attr_list, i5))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attr_count", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->attr_count, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sai_thrift_attribute_list_t_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  sai_thrift_attribute_list_t *self = SAI_THRIFT_ATTRIBUTE_LIST_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_LIST:
      if (self->attr_list != NULL)
        g_ptr_array_unref (self->attr_list);
      self->attr_list = g_value_dup_boxed (value);
      self->__isset_attr_list = TRUE;
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_COUNT:
      self->attr_count = g_value_get_int (value);
      self->__isset_attr_count = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sai_thrift_attribute_list_t_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  sai_thrift_attribute_list_t *self = SAI_THRIFT_ATTRIBUTE_LIST_T (object);

  switch (property_id)
  {
    case PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_LIST:
      g_value_set_boxed (value, self->attr_list);
      break;

    case PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_COUNT:
      g_value_set_int (value, self->attr_count);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sai_thrift_attribute_list_t_instance_init (sai_thrift_attribute_list_t * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_attr_list = FALSE;
  object->attr_count = 0;
  object->__isset_attr_count = FALSE;
}

static void 
sai_thrift_attribute_list_t_finalize (GObject *object)
{
  sai_thrift_attribute_list_t *tobject = SAI_THRIFT_ATTRIBUTE_LIST_T (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->attr_list != NULL)
  {
    g_ptr_array_unref (tobject->attr_list);
    tobject->attr_list = NULL;
  }
}

static void
sai_thrift_attribute_list_t_class_init (sai_thrift_attribute_list_tClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sai_thrift_attribute_list_t_read;
  struct_class->write = sai_thrift_attribute_list_t_write;

  gobject_class->finalize = sai_thrift_attribute_list_t_finalize;
  gobject_class->get_property = sai_thrift_attribute_list_t_get_property;
  gobject_class->set_property = sai_thrift_attribute_list_t_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_LIST,
     g_param_spec_boxed ("attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SAI_THRIFT_ATTRIBUTE_LIST_T_ATTR_COUNT,
     g_param_spec_int ("attr_count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
sai_thrift_attribute_list_t_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (sai_thrift_attribute_list_tClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sai_thrift_attribute_list_t_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (sai_thrift_attribute_list_t),
      0, /* n_preallocs */
      (GInstanceInitFunc) sai_thrift_attribute_list_t_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "sai_thrift_attribute_list_tType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _switch_sai_rpcSaiThriftSetPortAttributeArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_PORT_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_THRIFT_ATTR
};

/* reads a switch_sai_rpc_sai_thrift_set_port_attribute_args object */
static gint32
switch_sai_rpc_sai_thrift_set_port_attribute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetPortAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->port_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_attr), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_attr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_port_attribute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetPortAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetPortAttributeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->port_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_attr), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_port_attribute_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetPortAttributeArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_PORT_ID:
      self->port_id = g_value_get_int64 (value);
      self->__isset_port_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_THRIFT_ATTR:
      if (self->thrift_attr != NULL)
        g_object_unref (self->thrift_attr);
      self->thrift_attr = g_value_dup_object (value);
      self->__isset_thrift_attr = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_port_attribute_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetPortAttributeArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_PORT_ID:
      g_value_set_int64 (value, self->port_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_THRIFT_ATTR:
      g_value_set_object (value, self->thrift_attr);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_port_attribute_args_instance_init (switch_sai_rpcSaiThriftSetPortAttributeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->port_id = 0;
  object->__isset_port_id = FALSE;
  object->thrift_attr = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
  object->__isset_thrift_attr = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_port_attribute_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetPortAttributeArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr != NULL)
  {
    g_object_unref(tobject->thrift_attr);
    tobject->thrift_attr = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_set_port_attribute_args_class_init (switch_sai_rpcSaiThriftSetPortAttributeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_port_attribute_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_port_attribute_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_port_attribute_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_port_attribute_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_port_attribute_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_PORT_ID,
     g_param_spec_int64 ("port_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_ARGS_THRIFT_ATTR,
     g_param_spec_object ("thrift_attr",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ATTRIBUTE_T,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_port_attribute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetPortAttributeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_port_attribute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetPortAttributeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_port_attribute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetPortAttributeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftSetPortAttributeResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_set_port_attribute_result object */
static gint32
switch_sai_rpc_sai_thrift_set_port_attribute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetPortAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_port_attribute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetPortAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetPortAttributeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_port_attribute_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetPortAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_port_attribute_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetPortAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_port_attribute_result_instance_init (switch_sai_rpcSaiThriftSetPortAttributeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_port_attribute_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetPortAttributeResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_set_port_attribute_result_class_init (switch_sai_rpcSaiThriftSetPortAttributeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_port_attribute_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_port_attribute_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_port_attribute_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_port_attribute_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_port_attribute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_PORT_ATTRIBUTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_port_attribute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetPortAttributeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_port_attribute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetPortAttributeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_port_attribute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetPortAttributeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateFdbEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_fdb_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_create_fdb_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateFdbEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_fdb_entry), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_fdb_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem6 = NULL;
              if ( _elem6 != NULL)
              {
                g_object_unref (_elem6);
              }
              _elem6 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
              {
                g_object_unref (_elem6);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_fdb_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateFdbEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateFdbEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_fdb_entry", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_fdb_entry), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i7;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i7 = 0; i7 < this_object->thrift_attr_list->len; i7++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i7))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_fdb_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateFdbEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY:
      if (self->thrift_fdb_entry != NULL)
        g_object_unref (self->thrift_fdb_entry);
      self->thrift_fdb_entry = g_value_dup_object (value);
      self->__isset_thrift_fdb_entry = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_fdb_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateFdbEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY:
      g_value_set_object (value, self->thrift_fdb_entry);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_fdb_entry_args_instance_init (switch_sai_rpcSaiThriftCreateFdbEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_fdb_entry = g_object_new (TYPE_SAI_THRIFT_FDB_ENTRY_T, NULL);
  object->__isset_thrift_fdb_entry = FALSE;
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_fdb_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateFdbEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_fdb_entry != NULL)
  {
    g_object_unref(tobject->thrift_fdb_entry);
    tobject->thrift_fdb_entry = NULL;
  }
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_fdb_entry_args_class_init (switch_sai_rpcSaiThriftCreateFdbEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_fdb_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_fdb_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_fdb_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_fdb_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_fdb_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY,
     g_param_spec_object ("thrift_fdb_entry",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_FDB_ENTRY_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_fdb_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateFdbEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_fdb_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateFdbEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_fdb_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateFdbEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateFdbEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_fdb_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_create_fdb_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateFdbEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_fdb_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateFdbEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateFdbEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_fdb_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateFdbEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_fdb_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateFdbEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_fdb_entry_result_instance_init (switch_sai_rpcSaiThriftCreateFdbEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_fdb_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateFdbEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_fdb_entry_result_class_init (switch_sai_rpcSaiThriftCreateFdbEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_fdb_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_fdb_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_fdb_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_fdb_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_fdb_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_FDB_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_fdb_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateFdbEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_fdb_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateFdbEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_fdb_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateFdbEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteFdbEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY
};

/* reads a switch_sai_rpc_sai_thrift_delete_fdb_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteFdbEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_fdb_entry), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_fdb_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteFdbEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteFdbEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_fdb_entry", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_fdb_entry), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteFdbEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY:
      if (self->thrift_fdb_entry != NULL)
        g_object_unref (self->thrift_fdb_entry);
      self->thrift_fdb_entry = g_value_dup_object (value);
      self->__isset_thrift_fdb_entry = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteFdbEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY:
      g_value_set_object (value, self->thrift_fdb_entry);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_instance_init (switch_sai_rpcSaiThriftDeleteFdbEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_fdb_entry = g_object_new (TYPE_SAI_THRIFT_FDB_ENTRY_T, NULL);
  object->__isset_thrift_fdb_entry = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteFdbEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_fdb_entry != NULL)
  {
    g_object_unref(tobject->thrift_fdb_entry);
    tobject->thrift_fdb_entry = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_class_init (switch_sai_rpcSaiThriftDeleteFdbEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_fdb_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_fdb_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_fdb_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_fdb_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_fdb_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_ARGS_THRIFT_FDB_ENTRY,
     g_param_spec_object ("thrift_fdb_entry",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_FDB_ENTRY_T,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_fdb_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteFdbEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_fdb_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteFdbEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_fdb_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteFdbEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteFdbEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_delete_fdb_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteFdbEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteFdbEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteFdbEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteFdbEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteFdbEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_instance_init (switch_sai_rpcSaiThriftDeleteFdbEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteFdbEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_class_init (switch_sai_rpcSaiThriftDeleteFdbEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_fdb_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_fdb_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_fdb_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_fdb_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_fdb_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_FDB_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_fdb_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteFdbEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_fdb_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteFdbEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_fdb_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteFdbEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftFlushFdbEntriesArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_flush_fdb_entries_args object */
static gint32
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftFlushFdbEntriesArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem8 = NULL;
              if ( _elem8 != NULL)
              {
                g_object_unref (_elem8);
              }
              _elem8 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem8), protocol, error)) < 0)
              {
                g_object_unref (_elem8);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftFlushFdbEntriesArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftFlushFdbEntriesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i9;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i9 = 0; i9 < this_object->thrift_attr_list->len; i9++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i9))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftFlushFdbEntriesArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftFlushFdbEntriesArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_instance_init (switch_sai_rpcSaiThriftFlushFdbEntriesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftFlushFdbEntriesArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_class_init (switch_sai_rpcSaiThriftFlushFdbEntriesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_flush_fdb_entries_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_flush_fdb_entries_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_flush_fdb_entries_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_flush_fdb_entries_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_flush_fdb_entries_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_flush_fdb_entries_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftFlushFdbEntriesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_flush_fdb_entries_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftFlushFdbEntriesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_flush_fdb_entries_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftFlushFdbEntriesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftFlushFdbEntriesResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_flush_fdb_entries_result object */
static gint32
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftFlushFdbEntriesResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftFlushFdbEntriesResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftFlushFdbEntriesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftFlushFdbEntriesResult *self = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftFlushFdbEntriesResult *self = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_instance_init (switch_sai_rpcSaiThriftFlushFdbEntriesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftFlushFdbEntriesResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_class_init (switch_sai_rpcSaiThriftFlushFdbEntriesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_flush_fdb_entries_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_flush_fdb_entries_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_flush_fdb_entries_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_flush_fdb_entries_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_flush_fdb_entries_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_FLUSH_FDB_ENTRIES_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_flush_fdb_entries_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftFlushFdbEntriesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_flush_fdb_entries_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftFlushFdbEntriesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_flush_fdb_entries_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftFlushFdbEntriesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateVlanArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS_VLAN_ID
};

/* reads a switch_sai_rpc_sai_thrift_create_vlan_args object */
static gint32
switch_sai_rpc_sai_thrift_create_vlan_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->vlan_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vlan_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_vlan_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateVlanArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->vlan_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_vlan_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS_VLAN_ID:
      self->vlan_id = g_value_get_int (value);
      self->__isset_vlan_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_vlan_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS_VLAN_ID:
      g_value_set_int (value, self->vlan_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_vlan_args_instance_init (switch_sai_rpcSaiThriftCreateVlanArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vlan_id = 0;
  object->__isset_vlan_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_vlan_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateVlanArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_vlan_args_class_init (switch_sai_rpcSaiThriftCreateVlanArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_vlan_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_vlan_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_vlan_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_vlan_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_vlan_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_ARGS_VLAN_ID,
     g_param_spec_int ("vlan_id",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_vlan_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateVlanArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_vlan_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateVlanArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_vlan_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateVlanArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateVlanResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_vlan_result object */
static gint32
switch_sai_rpc_sai_thrift_create_vlan_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_vlan_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateVlanResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_vlan_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_vlan_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_vlan_result_instance_init (switch_sai_rpcSaiThriftCreateVlanResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_vlan_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateVlanResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_vlan_result_class_init (switch_sai_rpcSaiThriftCreateVlanResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_vlan_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_vlan_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_vlan_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_vlan_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_vlan_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VLAN_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_vlan_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateVlanResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_vlan_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateVlanResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_vlan_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateVlanResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteVlanArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS_VLAN_ID
};

/* reads a switch_sai_rpc_sai_thrift_delete_vlan_args object */
static gint32
switch_sai_rpc_sai_thrift_delete_vlan_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->vlan_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vlan_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_vlan_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteVlanArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->vlan_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_vlan_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS_VLAN_ID:
      self->vlan_id = g_value_get_int (value);
      self->__isset_vlan_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_vlan_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS_VLAN_ID:
      g_value_set_int (value, self->vlan_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_vlan_args_instance_init (switch_sai_rpcSaiThriftDeleteVlanArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vlan_id = 0;
  object->__isset_vlan_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_vlan_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteVlanArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_vlan_args_class_init (switch_sai_rpcSaiThriftDeleteVlanArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_vlan_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_vlan_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_vlan_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_vlan_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_vlan_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_ARGS_VLAN_ID,
     g_param_spec_int ("vlan_id",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_vlan_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteVlanArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_vlan_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteVlanArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_vlan_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteVlanArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteVlanResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_delete_vlan_result object */
static gint32
switch_sai_rpc_sai_thrift_delete_vlan_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_vlan_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteVlanResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_vlan_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_vlan_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_vlan_result_instance_init (switch_sai_rpcSaiThriftDeleteVlanResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_vlan_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteVlanResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_vlan_result_class_init (switch_sai_rpcSaiThriftDeleteVlanResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_vlan_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_vlan_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_vlan_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_vlan_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_vlan_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_VLAN_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_vlan_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteVlanResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_vlan_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteVlanResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_vlan_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteVlanResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftAddPortsToVlanArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_VLAN_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_THRIFT_PORT_LIST
};

/* reads a switch_sai_rpc_sai_thrift_add_ports_to_vlan_args object */
static gint32
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftAddPortsToVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->vlan_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vlan_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_vlan_port_t * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_SAI_THRIFT_VLAN_PORT_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_port_list, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_port_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftAddPortsToVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftAddPortsToVlanArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->vlan_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_port_list", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i11;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_port_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i11 = 0; i11 < this_object->thrift_port_list->len; i11++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_port_list, i11))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddPortsToVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_VLAN_ID:
      self->vlan_id = g_value_get_int (value);
      self->__isset_vlan_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_THRIFT_PORT_LIST:
      if (self->thrift_port_list != NULL)
        g_ptr_array_unref (self->thrift_port_list);
      self->thrift_port_list = g_value_dup_boxed (value);
      self->__isset_thrift_port_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddPortsToVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_VLAN_ID:
      g_value_set_int (value, self->vlan_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_THRIFT_PORT_LIST:
      g_value_set_boxed (value, self->thrift_port_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_instance_init (switch_sai_rpcSaiThriftAddPortsToVlanArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vlan_id = 0;
  object->__isset_vlan_id = FALSE;
  object->thrift_port_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_port_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftAddPortsToVlanArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_port_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_port_list);
    tobject->thrift_port_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_class_init (switch_sai_rpcSaiThriftAddPortsToVlanArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_VLAN_ID,
     g_param_spec_int ("vlan_id",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_ARGS_THRIFT_PORT_LIST,
     g_param_spec_boxed ("thrift_port_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftAddPortsToVlanArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftAddPortsToVlanArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_add_ports_to_vlan_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftAddPortsToVlanArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftAddPortsToVlanResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_add_ports_to_vlan_result object */
static gint32
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftAddPortsToVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftAddPortsToVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftAddPortsToVlanResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddPortsToVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddPortsToVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_instance_init (switch_sai_rpcSaiThriftAddPortsToVlanResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftAddPortsToVlanResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_class_init (switch_sai_rpcSaiThriftAddPortsToVlanResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_PORTS_TO_VLAN_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftAddPortsToVlanResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftAddPortsToVlanResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_add_ports_to_vlan_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftAddPortsToVlanResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemovePortsFromVlanArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_VLAN_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_THRIFT_PORT_LIST
};

/* reads a switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemovePortsFromVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->vlan_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vlan_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_vlan_port_t * _elem12 = NULL;
              if ( _elem12 != NULL)
              {
                g_object_unref (_elem12);
              }
              _elem12 = g_object_new (TYPE_SAI_THRIFT_VLAN_PORT_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem12), protocol, error)) < 0)
              {
                g_object_unref (_elem12);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_port_list, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_port_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemovePortsFromVlanArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemovePortsFromVlanArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->vlan_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_port_list", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i13;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_port_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i13 = 0; i13 < this_object->thrift_port_list->len; i13++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_port_list, i13))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePortsFromVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_VLAN_ID:
      self->vlan_id = g_value_get_int (value);
      self->__isset_vlan_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_THRIFT_PORT_LIST:
      if (self->thrift_port_list != NULL)
        g_ptr_array_unref (self->thrift_port_list);
      self->thrift_port_list = g_value_dup_boxed (value);
      self->__isset_thrift_port_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePortsFromVlanArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_VLAN_ID:
      g_value_set_int (value, self->vlan_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_THRIFT_PORT_LIST:
      g_value_set_boxed (value, self->thrift_port_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_instance_init (switch_sai_rpcSaiThriftRemovePortsFromVlanArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vlan_id = 0;
  object->__isset_vlan_id = FALSE;
  object->thrift_port_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_port_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemovePortsFromVlanArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_port_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_port_list);
    tobject->thrift_port_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_class_init (switch_sai_rpcSaiThriftRemovePortsFromVlanArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_VLAN_ID,
     g_param_spec_int ("vlan_id",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_ARGS_THRIFT_PORT_LIST,
     g_param_spec_boxed ("thrift_port_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemovePortsFromVlanArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemovePortsFromVlanArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_ports_from_vlan_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemovePortsFromVlanArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemovePortsFromVlanResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemovePortsFromVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemovePortsFromVlanResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemovePortsFromVlanResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_set_property (GObject *object,
                                                                      guint property_id,
                                                                      const GValue *value,
                                                                      GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePortsFromVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_get_property (GObject *object,
                                                                      guint property_id,
                                                                      GValue *value,
                                                                      GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePortsFromVlanResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_instance_init (switch_sai_rpcSaiThriftRemovePortsFromVlanResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemovePortsFromVlanResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_class_init (switch_sai_rpcSaiThriftRemovePortsFromVlanResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_PORTS_FROM_VLAN_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemovePortsFromVlanResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemovePortsFromVlanResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_ports_from_vlan_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemovePortsFromVlanResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetVlanStatsArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_VLAN_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_COUNTER_IDS,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_NUMBER_OF_COUNTERS
};

/* reads a switch_sai_rpc_sai_thrift_get_vlan_stats_args object */
static gint32
switch_sai_rpc_sai_thrift_get_vlan_stats_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetVlanStatsArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->vlan_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vlan_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem14 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem14, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->counter_ids, _elem14, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_counter_ids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->number_of_counters, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_number_of_counters = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_vlan_stats_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetVlanStatsArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetVlanStatsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vlan_id", T_I16, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i16 (protocol, this_object->vlan_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "counter_ids", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i15;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->counter_ids->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i15 = 0; i15 < this_object->counter_ids->len; i15++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->counter_ids, gint32, i15)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "number_of_counters", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->number_of_counters, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_vlan_stats_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetVlanStatsArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_VLAN_ID:
      self->vlan_id = g_value_get_int (value);
      self->__isset_vlan_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_COUNTER_IDS:
      if (self->counter_ids != NULL)
        g_array_unref (self->counter_ids);
      self->counter_ids = g_value_dup_boxed (value);
      self->__isset_counter_ids = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_NUMBER_OF_COUNTERS:
      self->number_of_counters = g_value_get_int (value);
      self->__isset_number_of_counters = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_vlan_stats_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetVlanStatsArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_VLAN_ID:
      g_value_set_int (value, self->vlan_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_COUNTER_IDS:
      g_value_set_boxed (value, self->counter_ids);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_NUMBER_OF_COUNTERS:
      g_value_set_int (value, self->number_of_counters);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_vlan_stats_args_instance_init (switch_sai_rpcSaiThriftGetVlanStatsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vlan_id = 0;
  object->__isset_vlan_id = FALSE;
  object->counter_ids = g_array_new (0, 1, sizeof (gint32));
  object->__isset_counter_ids = FALSE;
  object->number_of_counters = 0;
  object->__isset_number_of_counters = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_vlan_stats_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetVlanStatsArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->counter_ids != NULL)
  {
    g_array_unref (tobject->counter_ids);
    tobject->counter_ids = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_get_vlan_stats_args_class_init (switch_sai_rpcSaiThriftGetVlanStatsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_vlan_stats_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_vlan_stats_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_vlan_stats_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_vlan_stats_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_vlan_stats_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_VLAN_ID,
     g_param_spec_int ("vlan_id",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_COUNTER_IDS,
     g_param_spec_boxed ("counter_ids",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_ARGS_NUMBER_OF_COUNTERS,
     g_param_spec_int ("number_of_counters",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_vlan_stats_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetVlanStatsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_vlan_stats_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetVlanStatsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_vlan_stats_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetVlanStatsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetVlanStatsResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_get_vlan_stats_result object */
static gint32
switch_sai_rpc_sai_thrift_get_vlan_stats_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetVlanStatsResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem16 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem16, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem16, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_vlan_stats_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetVlanStatsResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetVlanStatsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i17;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i17 = 0; i17 < this_object->success->len; i17++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->success, gint64, i17)), error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_vlan_stats_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetVlanStatsResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_vlan_stats_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetVlanStatsResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_vlan_stats_result_instance_init (switch_sai_rpcSaiThriftGetVlanStatsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint64));
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_vlan_stats_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetVlanStatsResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_get_vlan_stats_result_class_init (switch_sai_rpcSaiThriftGetVlanStatsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_vlan_stats_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_vlan_stats_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_vlan_stats_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_vlan_stats_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_vlan_stats_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_VLAN_STATS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_vlan_stats_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetVlanStatsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_vlan_stats_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetVlanStatsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_vlan_stats_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetVlanStatsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateVirtualRouterArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_virtual_router_args object */
static gint32
switch_sai_rpc_sai_thrift_create_virtual_router_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateVirtualRouterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem18 = NULL;
              if ( _elem18 != NULL)
              {
                g_object_unref (_elem18);
              }
              _elem18 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem18), protocol, error)) < 0)
              {
                g_object_unref (_elem18);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem18);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_virtual_router_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateVirtualRouterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateVirtualRouterArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i19;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i19 = 0; i19 < this_object->thrift_attr_list->len; i19++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i19))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_virtual_router_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVirtualRouterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_virtual_router_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVirtualRouterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_virtual_router_args_instance_init (switch_sai_rpcSaiThriftCreateVirtualRouterArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_virtual_router_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateVirtualRouterArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_virtual_router_args_class_init (switch_sai_rpcSaiThriftCreateVirtualRouterArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_virtual_router_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_virtual_router_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_virtual_router_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_virtual_router_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_virtual_router_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_virtual_router_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateVirtualRouterArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_virtual_router_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateVirtualRouterArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_virtual_router_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateVirtualRouterArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateVirtualRouterResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_virtual_router_result object */
static gint32
switch_sai_rpc_sai_thrift_create_virtual_router_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateVirtualRouterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_virtual_router_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateVirtualRouterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateVirtualRouterResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_virtual_router_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVirtualRouterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_virtual_router_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateVirtualRouterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_virtual_router_result_instance_init (switch_sai_rpcSaiThriftCreateVirtualRouterResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_virtual_router_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateVirtualRouterResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_virtual_router_result_class_init (switch_sai_rpcSaiThriftCreateVirtualRouterResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_virtual_router_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_virtual_router_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_virtual_router_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_virtual_router_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_virtual_router_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_VIRTUAL_ROUTER_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_virtual_router_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateVirtualRouterResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_virtual_router_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateVirtualRouterResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_virtual_router_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateVirtualRouterResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveVirtualRouterArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS_VR_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_virtual_router_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_virtual_router_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveVirtualRouterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->vr_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vr_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_virtual_router_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveVirtualRouterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveVirtualRouterArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "vr_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->vr_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_virtual_router_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveVirtualRouterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS_VR_ID:
      self->vr_id = g_value_get_int64 (value);
      self->__isset_vr_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_virtual_router_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveVirtualRouterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS_VR_ID:
      g_value_set_int64 (value, self->vr_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_virtual_router_args_instance_init (switch_sai_rpcSaiThriftRemoveVirtualRouterArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->vr_id = 0;
  object->__isset_vr_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_virtual_router_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveVirtualRouterArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_virtual_router_args_class_init (switch_sai_rpcSaiThriftRemoveVirtualRouterArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_virtual_router_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_virtual_router_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_virtual_router_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_virtual_router_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_virtual_router_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_ARGS_VR_ID,
     g_param_spec_int64 ("vr_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_virtual_router_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveVirtualRouterArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_virtual_router_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveVirtualRouterArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_virtual_router_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveVirtualRouterArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveVirtualRouterResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_virtual_router_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_virtual_router_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveVirtualRouterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_virtual_router_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveVirtualRouterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveVirtualRouterResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_virtual_router_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveVirtualRouterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_virtual_router_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveVirtualRouterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_virtual_router_result_instance_init (switch_sai_rpcSaiThriftRemoveVirtualRouterResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_virtual_router_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveVirtualRouterResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_virtual_router_result_class_init (switch_sai_rpcSaiThriftRemoveVirtualRouterResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_virtual_router_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_virtual_router_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_virtual_router_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_virtual_router_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_virtual_router_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_VIRTUAL_ROUTER_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_virtual_router_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveVirtualRouterResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_virtual_router_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveVirtualRouterResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_virtual_router_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveVirtualRouterResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateRouteArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_route_args object */
static gint32
switch_sai_rpc_sai_thrift_create_route_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateRouteArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_unicast_route_entry), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_unicast_route_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem20 = NULL;
              if ( _elem20 != NULL)
              {
                g_object_unref (_elem20);
              }
              _elem20 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem20), protocol, error)) < 0)
              {
                g_object_unref (_elem20);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem20);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_route_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateRouteArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateRouteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_unicast_route_entry", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_unicast_route_entry), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i21;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i21 = 0; i21 < this_object->thrift_attr_list->len; i21++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i21))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_route_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouteArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY:
      if (self->thrift_unicast_route_entry != NULL)
        g_object_unref (self->thrift_unicast_route_entry);
      self->thrift_unicast_route_entry = g_value_dup_object (value);
      self->__isset_thrift_unicast_route_entry = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_route_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouteArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY:
      g_value_set_object (value, self->thrift_unicast_route_entry);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_route_args_instance_init (switch_sai_rpcSaiThriftCreateRouteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_unicast_route_entry = g_object_new (TYPE_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T, NULL);
  object->__isset_thrift_unicast_route_entry = FALSE;
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_route_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateRouteArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_unicast_route_entry != NULL)
  {
    g_object_unref(tobject->thrift_unicast_route_entry);
    tobject->thrift_unicast_route_entry = NULL;
  }
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_route_args_class_init (switch_sai_rpcSaiThriftCreateRouteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_route_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_route_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_route_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_route_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_route_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY,
     g_param_spec_object ("thrift_unicast_route_entry",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_route_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateRouteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_route_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateRouteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_route_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateRouteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateRouteResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_route_result object */
static gint32
switch_sai_rpc_sai_thrift_create_route_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateRouteResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_route_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateRouteResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateRouteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_route_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouteResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_route_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouteResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_route_result_instance_init (switch_sai_rpcSaiThriftCreateRouteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_route_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateRouteResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_route_result_class_init (switch_sai_rpcSaiThriftCreateRouteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_route_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_route_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_route_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_route_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_route_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_route_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateRouteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_route_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateRouteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_route_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateRouteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveRouteArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY
};

/* reads a switch_sai_rpc_sai_thrift_remove_route_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_route_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveRouteArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_unicast_route_entry), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_unicast_route_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_route_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveRouteArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveRouteArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_unicast_route_entry", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_unicast_route_entry), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_route_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouteArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY:
      if (self->thrift_unicast_route_entry != NULL)
        g_object_unref (self->thrift_unicast_route_entry);
      self->thrift_unicast_route_entry = g_value_dup_object (value);
      self->__isset_thrift_unicast_route_entry = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_route_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouteArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY:
      g_value_set_object (value, self->thrift_unicast_route_entry);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_route_args_instance_init (switch_sai_rpcSaiThriftRemoveRouteArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_unicast_route_entry = g_object_new (TYPE_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T, NULL);
  object->__isset_thrift_unicast_route_entry = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_route_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveRouteArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_unicast_route_entry != NULL)
  {
    g_object_unref(tobject->thrift_unicast_route_entry);
    tobject->thrift_unicast_route_entry = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_route_args_class_init (switch_sai_rpcSaiThriftRemoveRouteArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_route_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_route_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_route_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_route_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_route_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_ARGS_THRIFT_UNICAST_ROUTE_ENTRY,
     g_param_spec_object ("thrift_unicast_route_entry",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_UNICAST_ROUTE_ENTRY_T,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_route_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveRouteArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_route_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveRouteArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_route_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveRouteArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveRouteResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_route_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_route_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveRouteResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_route_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveRouteResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveRouteResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_route_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouteResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_route_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouteResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_route_result_instance_init (switch_sai_rpcSaiThriftRemoveRouteResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_route_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveRouteResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_route_result_class_init (switch_sai_rpcSaiThriftRemoveRouteResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_route_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_route_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_route_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_route_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_route_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_route_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveRouteResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_route_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveRouteResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_route_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveRouteResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateRouterInterfaceArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_router_interface_args object */
static gint32
switch_sai_rpc_sai_thrift_create_router_interface_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateRouterInterfaceArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem22 = NULL;
              if ( _elem22 != NULL)
              {
                g_object_unref (_elem22);
              }
              _elem22 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem22), protocol, error)) < 0)
              {
                g_object_unref (_elem22);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem22);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_router_interface_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateRouterInterfaceArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateRouterInterfaceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i23;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i23 = 0; i23 < this_object->thrift_attr_list->len; i23++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i23))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_router_interface_args_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouterInterfaceArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_router_interface_args_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouterInterfaceArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_router_interface_args_instance_init (switch_sai_rpcSaiThriftCreateRouterInterfaceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_router_interface_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateRouterInterfaceArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_router_interface_args_class_init (switch_sai_rpcSaiThriftCreateRouterInterfaceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_router_interface_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_router_interface_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_router_interface_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_router_interface_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_router_interface_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_router_interface_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateRouterInterfaceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_router_interface_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateRouterInterfaceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_router_interface_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateRouterInterfaceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateRouterInterfaceResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_router_interface_result object */
static gint32
switch_sai_rpc_sai_thrift_create_router_interface_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateRouterInterfaceResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_router_interface_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateRouterInterfaceResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateRouterInterfaceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_router_interface_result_set_property (GObject *object,
                                                                       guint property_id,
                                                                       const GValue *value,
                                                                       GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouterInterfaceResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_router_interface_result_get_property (GObject *object,
                                                                       guint property_id,
                                                                       GValue *value,
                                                                       GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateRouterInterfaceResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_router_interface_result_instance_init (switch_sai_rpcSaiThriftCreateRouterInterfaceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_router_interface_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateRouterInterfaceResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_router_interface_result_class_init (switch_sai_rpcSaiThriftCreateRouterInterfaceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_router_interface_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_router_interface_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_router_interface_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_router_interface_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_router_interface_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ROUTER_INTERFACE_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_router_interface_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateRouterInterfaceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_router_interface_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateRouterInterfaceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_router_interface_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateRouterInterfaceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveRouterInterfaceArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS_RIF_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_router_interface_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_router_interface_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->rif_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rif_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_router_interface_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rif_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->rif_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_router_interface_args_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS_RIF_ID:
      self->rif_id = g_value_get_int64 (value);
      self->__isset_rif_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_router_interface_args_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS_RIF_ID:
      g_value_set_int64 (value, self->rif_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_router_interface_args_instance_init (switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->rif_id = 0;
  object->__isset_rif_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_router_interface_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_router_interface_args_class_init (switch_sai_rpcSaiThriftRemoveRouterInterfaceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_router_interface_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_router_interface_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_router_interface_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_router_interface_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_router_interface_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_ARGS_RIF_ID,
     g_param_spec_int64 ("rif_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_router_interface_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveRouterInterfaceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_router_interface_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveRouterInterfaceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_router_interface_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveRouterInterfaceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveRouterInterfaceResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_router_interface_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_router_interface_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveRouterInterfaceResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_router_interface_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveRouterInterfaceResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveRouterInterfaceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_router_interface_result_set_property (GObject *object,
                                                                       guint property_id,
                                                                       const GValue *value,
                                                                       GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouterInterfaceResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_router_interface_result_get_property (GObject *object,
                                                                       guint property_id,
                                                                       GValue *value,
                                                                       GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveRouterInterfaceResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_router_interface_result_instance_init (switch_sai_rpcSaiThriftRemoveRouterInterfaceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_router_interface_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveRouterInterfaceResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_router_interface_result_class_init (switch_sai_rpcSaiThriftRemoveRouterInterfaceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_router_interface_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_router_interface_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_router_interface_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_router_interface_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_router_interface_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_ROUTER_INTERFACE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_router_interface_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveRouterInterfaceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_router_interface_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveRouterInterfaceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_router_interface_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveRouterInterfaceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateNextHopArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_next_hop_args object */
static gint32
switch_sai_rpc_sai_thrift_create_next_hop_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateNextHopArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem24 = NULL;
              if ( _elem24 != NULL)
              {
                g_object_unref (_elem24);
              }
              _elem24 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem24), protocol, error)) < 0)
              {
                g_object_unref (_elem24);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem24);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_next_hop_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateNextHopArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateNextHopArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i25;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i25 = 0; i25 < this_object->thrift_attr_list->len; i25++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i25))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_args_instance_init (switch_sai_rpcSaiThriftCreateNextHopArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateNextHopArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_args_class_init (switch_sai_rpcSaiThriftCreateNextHopArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_next_hop_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_next_hop_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_next_hop_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_next_hop_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_next_hop_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_next_hop_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateNextHopArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateNextHopArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateNextHopArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateNextHopResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_next_hop_result object */
static gint32
switch_sai_rpc_sai_thrift_create_next_hop_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateNextHopResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_next_hop_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateNextHopResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateNextHopResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_result_instance_init (switch_sai_rpcSaiThriftCreateNextHopResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateNextHopResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_result_class_init (switch_sai_rpcSaiThriftCreateNextHopResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_next_hop_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_next_hop_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_next_hop_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_next_hop_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_next_hop_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_next_hop_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateNextHopResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateNextHopResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateNextHopResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNextHopArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS_NEXT_HOP_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_next_hop_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNextHopArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->next_hop_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_next_hop_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNextHopArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNextHopArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->next_hop_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS_NEXT_HOP_ID:
      self->next_hop_id = g_value_get_int64 (value);
      self->__isset_next_hop_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS_NEXT_HOP_ID:
      g_value_set_int64 (value, self->next_hop_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_args_instance_init (switch_sai_rpcSaiThriftRemoveNextHopArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->next_hop_id = 0;
  object->__isset_next_hop_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNextHopArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_args_class_init (switch_sai_rpcSaiThriftRemoveNextHopArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_next_hop_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_next_hop_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_next_hop_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_next_hop_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_next_hop_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_ARGS_NEXT_HOP_ID,
     g_param_spec_int64 ("next_hop_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_next_hop_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNextHopArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNextHopResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_next_hop_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNextHopResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNextHopResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNextHopResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_result_instance_init (switch_sai_rpcSaiThriftRemoveNextHopResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNextHopResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_result_class_init (switch_sai_rpcSaiThriftRemoveNextHopResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_next_hop_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_next_hop_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_next_hop_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_next_hop_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_next_hop_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_next_hop_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNextHopResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateNextHopGroupArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_next_hop_group_args object */
static gint32
switch_sai_rpc_sai_thrift_create_next_hop_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateNextHopGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem26 = NULL;
              if ( _elem26 != NULL)
              {
                g_object_unref (_elem26);
              }
              _elem26 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem26), protocol, error)) < 0)
              {
                g_object_unref (_elem26);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem26);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_next_hop_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateNextHopGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateNextHopGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i27;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i27 = 0; i27 < this_object->thrift_attr_list->len; i27++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i27))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_group_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_group_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_group_args_instance_init (switch_sai_rpcSaiThriftCreateNextHopGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_group_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateNextHopGroupArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_group_args_class_init (switch_sai_rpcSaiThriftCreateNextHopGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_next_hop_group_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_next_hop_group_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_next_hop_group_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_next_hop_group_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_next_hop_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_next_hop_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateNextHopGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateNextHopGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateNextHopGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateNextHopGroupResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_next_hop_group_result object */
static gint32
switch_sai_rpc_sai_thrift_create_next_hop_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateNextHopGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_next_hop_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateNextHopGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateNextHopGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_group_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_group_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNextHopGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_group_result_instance_init (switch_sai_rpcSaiThriftCreateNextHopGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_next_hop_group_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateNextHopGroupResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_next_hop_group_result_class_init (switch_sai_rpcSaiThriftCreateNextHopGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_next_hop_group_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_next_hop_group_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_next_hop_group_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_next_hop_group_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_next_hop_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEXT_HOP_GROUP_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_next_hop_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateNextHopGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateNextHopGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_next_hop_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateNextHopGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNextHopGroupArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS_NEXT_HOP_GROUP_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_next_hop_group_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNextHopGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->next_hop_group_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_next_hop_group_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNextHopGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNextHopGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_group_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->next_hop_group_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS_NEXT_HOP_GROUP_ID:
      self->next_hop_group_id = g_value_get_int64 (value);
      self->__isset_next_hop_group_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS_NEXT_HOP_GROUP_ID:
      g_value_set_int64 (value, self->next_hop_group_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_instance_init (switch_sai_rpcSaiThriftRemoveNextHopGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->next_hop_group_id = 0;
  object->__isset_next_hop_group_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNextHopGroupArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_class_init (switch_sai_rpcSaiThriftRemoveNextHopGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_next_hop_group_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_next_hop_group_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_next_hop_group_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_next_hop_group_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_next_hop_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_ARGS_NEXT_HOP_GROUP_ID,
     g_param_spec_int64 ("next_hop_group_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_next_hop_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNextHopGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNextHopGroupResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_next_hop_group_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNextHopGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNextHopGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNextHopGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_instance_init (switch_sai_rpcSaiThriftRemoveNextHopGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNextHopGroupResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_class_init (switch_sai_rpcSaiThriftRemoveNextHopGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_next_hop_group_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_next_hop_group_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_next_hop_group_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_next_hop_group_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_next_hop_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_GROUP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_next_hop_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNextHopGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftAddNextHopToGroupArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_NEXT_HOP_GROUP_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_THRIFT_NEXTHOPS
};

/* reads a switch_sai_rpc_sai_thrift_add_next_hop_to_group_args object */
static gint32
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftAddNextHopToGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->next_hop_group_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_next_hop_group_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem28 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem28, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->thrift_nexthops, _elem28, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_nexthops = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftAddNextHopToGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftAddNextHopToGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_group_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->next_hop_group_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_nexthops", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i29;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->thrift_nexthops->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i29 = 0; i29 < this_object->thrift_nexthops->len; i29++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->thrift_nexthops, gint64, i29)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddNextHopToGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_NEXT_HOP_GROUP_ID:
      self->next_hop_group_id = g_value_get_int64 (value);
      self->__isset_next_hop_group_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_THRIFT_NEXTHOPS:
      if (self->thrift_nexthops != NULL)
        g_array_unref (self->thrift_nexthops);
      self->thrift_nexthops = g_value_dup_boxed (value);
      self->__isset_thrift_nexthops = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddNextHopToGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_NEXT_HOP_GROUP_ID:
      g_value_set_int64 (value, self->next_hop_group_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_THRIFT_NEXTHOPS:
      g_value_set_boxed (value, self->thrift_nexthops);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_instance_init (switch_sai_rpcSaiThriftAddNextHopToGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->next_hop_group_id = 0;
  object->__isset_next_hop_group_id = FALSE;
  object->thrift_nexthops = g_array_new (0, 1, sizeof (gint64));
  object->__isset_thrift_nexthops = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftAddNextHopToGroupArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_nexthops != NULL)
  {
    g_array_unref (tobject->thrift_nexthops);
    tobject->thrift_nexthops = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_class_init (switch_sai_rpcSaiThriftAddNextHopToGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_NEXT_HOP_GROUP_ID,
     g_param_spec_int64 ("next_hop_group_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_ARGS_THRIFT_NEXTHOPS,
     g_param_spec_boxed ("thrift_nexthops",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftAddNextHopToGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftAddNextHopToGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_add_next_hop_to_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftAddNextHopToGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftAddNextHopToGroupResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_add_next_hop_to_group_result object */
static gint32
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftAddNextHopToGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftAddNextHopToGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftAddNextHopToGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddNextHopToGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftAddNextHopToGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_instance_init (switch_sai_rpcSaiThriftAddNextHopToGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftAddNextHopToGroupResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_class_init (switch_sai_rpcSaiThriftAddNextHopToGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_ADD_NEXT_HOP_TO_GROUP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftAddNextHopToGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftAddNextHopToGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_add_next_hop_to_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftAddNextHopToGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_NEXT_HOP_GROUP_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_THRIFT_NEXTHOPS
};

/* reads a switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->next_hop_group_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_next_hop_group_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem30 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem30, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->thrift_nexthops, _elem30, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_nexthops = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "next_hop_group_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->next_hop_group_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_nexthops", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i31;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->thrift_nexthops->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i31 = 0; i31 < this_object->thrift_nexthops->len; i31++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->thrift_nexthops, gint64, i31)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_set_property (GObject *object,
                                                                        guint property_id,
                                                                        const GValue *value,
                                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_NEXT_HOP_GROUP_ID:
      self->next_hop_group_id = g_value_get_int64 (value);
      self->__isset_next_hop_group_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_THRIFT_NEXTHOPS:
      if (self->thrift_nexthops != NULL)
        g_array_unref (self->thrift_nexthops);
      self->thrift_nexthops = g_value_dup_boxed (value);
      self->__isset_thrift_nexthops = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_get_property (GObject *object,
                                                                        guint property_id,
                                                                        GValue *value,
                                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_NEXT_HOP_GROUP_ID:
      g_value_set_int64 (value, self->next_hop_group_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_THRIFT_NEXTHOPS:
      g_value_set_boxed (value, self->thrift_nexthops);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_instance_init (switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->next_hop_group_id = 0;
  object->__isset_next_hop_group_id = FALSE;
  object->thrift_nexthops = g_array_new (0, 1, sizeof (gint64));
  object->__isset_thrift_nexthops = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_nexthops != NULL)
  {
    g_array_unref (tobject->thrift_nexthops);
    tobject->thrift_nexthops = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_class_init (switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_NEXT_HOP_GROUP_ID,
     g_param_spec_int64 ("next_hop_group_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_ARGS_THRIFT_NEXTHOPS,
     g_param_spec_boxed ("thrift_nexthops",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_from_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNextHopFromGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNextHopFromGroupResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_set_property (GObject *object,
                                                                          guint property_id,
                                                                          const GValue *value,
                                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_get_property (GObject *object,
                                                                          guint property_id,
                                                                          GValue *value,
                                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_instance_init (switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_class_init (switch_sai_rpcSaiThriftRemoveNextHopFromGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEXT_HOP_FROM_GROUP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopFromGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNextHopFromGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_next_hop_from_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNextHopFromGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateLagArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_lag_args object */
static gint32
switch_sai_rpc_sai_thrift_create_lag_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateLagArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem32 = NULL;
              if ( _elem32 != NULL)
              {
                g_object_unref (_elem32);
              }
              _elem32 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem32), protocol, error)) < 0)
              {
                g_object_unref (_elem32);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_lag_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateLagArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateLagArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i33;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i33 = 0; i33 < this_object->thrift_attr_list->len; i33++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i33))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_lag_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_lag_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_lag_args_instance_init (switch_sai_rpcSaiThriftCreateLagArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_lag_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateLagArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_lag_args_class_init (switch_sai_rpcSaiThriftCreateLagArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_lag_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_lag_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_lag_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_lag_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_lag_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_lag_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateLagArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_lag_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateLagArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_lag_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateLagArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateLagResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_lag_result object */
static gint32
switch_sai_rpc_sai_thrift_create_lag_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateLagResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_lag_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateLagResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateLagResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_lag_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_lag_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_lag_result_instance_init (switch_sai_rpcSaiThriftCreateLagResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_lag_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateLagResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_lag_result_class_init (switch_sai_rpcSaiThriftCreateLagResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_lag_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_lag_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_lag_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_lag_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_lag_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_lag_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateLagResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_lag_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateLagResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_lag_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateLagResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveLagArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS_LAG_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_lag_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_lag_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveLagArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->lag_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_lag_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_lag_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveLagArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveLagArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "lag_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->lag_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_lag_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS_LAG_ID:
      self->lag_id = g_value_get_int64 (value);
      self->__isset_lag_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_lag_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS_LAG_ID:
      g_value_set_int64 (value, self->lag_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_args_instance_init (switch_sai_rpcSaiThriftRemoveLagArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->lag_id = 0;
  object->__isset_lag_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveLagArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_lag_args_class_init (switch_sai_rpcSaiThriftRemoveLagArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_lag_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_lag_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_lag_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_lag_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_lag_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_ARGS_LAG_ID,
     g_param_spec_int64 ("lag_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_lag_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveLagArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_lag_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveLagArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_lag_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveLagArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveLagResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_lag_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_lag_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveLagResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_lag_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveLagResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveLagResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_lag_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_lag_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_result_instance_init (switch_sai_rpcSaiThriftRemoveLagResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveLagResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_lag_result_class_init (switch_sai_rpcSaiThriftRemoveLagResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_lag_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_lag_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_lag_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_lag_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_lag_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_lag_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveLagResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_lag_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveLagResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_lag_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveLagResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateLagMemberArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_lag_member_args object */
static gint32
switch_sai_rpc_sai_thrift_create_lag_member_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateLagMemberArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem34 = NULL;
              if ( _elem34 != NULL)
              {
                g_object_unref (_elem34);
              }
              _elem34 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem34), protocol, error)) < 0)
              {
                g_object_unref (_elem34);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem34);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_lag_member_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateLagMemberArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateLagMemberArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i35;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i35 = 0; i35 < this_object->thrift_attr_list->len; i35++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i35))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_lag_member_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagMemberArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_lag_member_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagMemberArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_lag_member_args_instance_init (switch_sai_rpcSaiThriftCreateLagMemberArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_lag_member_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateLagMemberArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_lag_member_args_class_init (switch_sai_rpcSaiThriftCreateLagMemberArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_lag_member_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_lag_member_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_lag_member_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_lag_member_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_lag_member_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_lag_member_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateLagMemberArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_lag_member_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateLagMemberArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_lag_member_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateLagMemberArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateLagMemberResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_lag_member_result object */
static gint32
switch_sai_rpc_sai_thrift_create_lag_member_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateLagMemberResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_lag_member_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateLagMemberResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateLagMemberResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_lag_member_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagMemberResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_lag_member_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateLagMemberResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_lag_member_result_instance_init (switch_sai_rpcSaiThriftCreateLagMemberResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_lag_member_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateLagMemberResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_lag_member_result_class_init (switch_sai_rpcSaiThriftCreateLagMemberResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_lag_member_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_lag_member_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_lag_member_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_lag_member_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_lag_member_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_LAG_MEMBER_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_lag_member_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateLagMemberResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_lag_member_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateLagMemberResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_lag_member_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateLagMemberResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveLagMemberArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS_LAG_MEMBER_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_lag_member_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_lag_member_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveLagMemberArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->lag_member_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_lag_member_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_lag_member_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveLagMemberArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveLagMemberArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "lag_member_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->lag_member_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_lag_member_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagMemberArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS_LAG_MEMBER_ID:
      self->lag_member_id = g_value_get_int64 (value);
      self->__isset_lag_member_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_lag_member_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagMemberArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS_LAG_MEMBER_ID:
      g_value_set_int64 (value, self->lag_member_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_member_args_instance_init (switch_sai_rpcSaiThriftRemoveLagMemberArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->lag_member_id = 0;
  object->__isset_lag_member_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_member_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveLagMemberArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_lag_member_args_class_init (switch_sai_rpcSaiThriftRemoveLagMemberArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_lag_member_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_lag_member_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_lag_member_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_lag_member_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_lag_member_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_ARGS_LAG_MEMBER_ID,
     g_param_spec_int64 ("lag_member_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_lag_member_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveLagMemberArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_lag_member_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveLagMemberArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_lag_member_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveLagMemberArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveLagMemberResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_lag_member_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_lag_member_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveLagMemberResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_lag_member_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveLagMemberResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveLagMemberResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_lag_member_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagMemberResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_lag_member_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveLagMemberResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_member_result_instance_init (switch_sai_rpcSaiThriftRemoveLagMemberResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_lag_member_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveLagMemberResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_lag_member_result_class_init (switch_sai_rpcSaiThriftRemoveLagMemberResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_lag_member_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_lag_member_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_lag_member_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_lag_member_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_lag_member_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_LAG_MEMBER_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_lag_member_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveLagMemberResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_lag_member_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveLagMemberResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_lag_member_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveLagMemberResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateStpEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_stp_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_create_stp_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateStpEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem36 = NULL;
              if ( _elem36 != NULL)
              {
                g_object_unref (_elem36);
              }
              _elem36 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem36), protocol, error)) < 0)
              {
                g_object_unref (_elem36);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem36);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_stp_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateStpEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateStpEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i37;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i37 = 0; i37 < this_object->thrift_attr_list->len; i37++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i37))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_stp_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateStpEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_stp_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateStpEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_stp_entry_args_instance_init (switch_sai_rpcSaiThriftCreateStpEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_stp_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateStpEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_stp_entry_args_class_init (switch_sai_rpcSaiThriftCreateStpEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_stp_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_stp_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_stp_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_stp_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_stp_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_stp_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateStpEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_stp_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateStpEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_stp_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateStpEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateStpEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_stp_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_create_stp_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateStpEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_stp_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateStpEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateStpEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_stp_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateStpEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_stp_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateStpEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_stp_entry_result_instance_init (switch_sai_rpcSaiThriftCreateStpEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_stp_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateStpEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_stp_entry_result_class_init (switch_sai_rpcSaiThriftCreateStpEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_stp_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_stp_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_stp_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_stp_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_stp_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_STP_ENTRY_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_stp_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateStpEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_stp_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateStpEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_stp_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateStpEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveStpEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS_STP_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_stp_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_stp_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveStpEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->stp_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_stp_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_stp_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveStpEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveStpEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stp_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->stp_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_stp_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveStpEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS_STP_ID:
      self->stp_id = g_value_get_int64 (value);
      self->__isset_stp_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_stp_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveStpEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS_STP_ID:
      g_value_set_int64 (value, self->stp_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_stp_entry_args_instance_init (switch_sai_rpcSaiThriftRemoveStpEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stp_id = 0;
  object->__isset_stp_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_stp_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveStpEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_stp_entry_args_class_init (switch_sai_rpcSaiThriftRemoveStpEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_stp_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_stp_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_stp_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_stp_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_stp_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_ARGS_STP_ID,
     g_param_spec_int64 ("stp_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_stp_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveStpEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_stp_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveStpEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_stp_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveStpEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveStpEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_stp_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_stp_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveStpEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_stp_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveStpEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveStpEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_stp_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveStpEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_stp_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveStpEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_stp_entry_result_instance_init (switch_sai_rpcSaiThriftRemoveStpEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_stp_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveStpEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_stp_entry_result_class_init (switch_sai_rpcSaiThriftRemoveStpEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_stp_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_stp_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_stp_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_stp_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_stp_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_STP_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_stp_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveStpEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_stp_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveStpEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_stp_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveStpEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftSetStpPortStateArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_PORT_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_PORT_STATE
};

/* reads a switch_sai_rpc_sai_thrift_set_stp_port_state_args object */
static gint32
switch_sai_rpc_sai_thrift_set_stp_port_state_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetStpPortStateArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->stp_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_stp_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->port_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->stp_port_state, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_stp_port_state = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_stp_port_state_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetStpPortStateArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetStpPortStateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stp_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->stp_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->port_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stp_port_state", T_BYTE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->stp_port_state, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_stp_port_state_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetStpPortStateArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_ID:
      self->stp_id = g_value_get_int64 (value);
      self->__isset_stp_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_PORT_ID:
      self->port_id = g_value_get_int64 (value);
      self->__isset_port_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_PORT_STATE:
      self->stp_port_state = g_value_get_int (value);
      self->__isset_stp_port_state = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_stp_port_state_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetStpPortStateArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_ID:
      g_value_set_int64 (value, self->stp_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_PORT_ID:
      g_value_set_int64 (value, self->port_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_PORT_STATE:
      g_value_set_int (value, self->stp_port_state);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_stp_port_state_args_instance_init (switch_sai_rpcSaiThriftSetStpPortStateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stp_id = 0;
  object->__isset_stp_id = FALSE;
  object->port_id = 0;
  object->__isset_port_id = FALSE;
  object->stp_port_state = 0;
  object->__isset_stp_port_state = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_stp_port_state_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetStpPortStateArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_set_stp_port_state_args_class_init (switch_sai_rpcSaiThriftSetStpPortStateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_stp_port_state_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_stp_port_state_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_stp_port_state_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_stp_port_state_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_stp_port_state_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_ID,
     g_param_spec_int64 ("stp_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_PORT_ID,
     g_param_spec_int64 ("port_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_ARGS_STP_PORT_STATE,
     g_param_spec_int ("stp_port_state",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_stp_port_state_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetStpPortStateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_stp_port_state_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetStpPortStateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_stp_port_state_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetStpPortStateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftSetStpPortStateResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_set_stp_port_state_result object */
static gint32
switch_sai_rpc_sai_thrift_set_stp_port_state_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetStpPortStateResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_stp_port_state_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetStpPortStateResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetStpPortStateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_stp_port_state_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetStpPortStateResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_stp_port_state_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetStpPortStateResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_stp_port_state_result_instance_init (switch_sai_rpcSaiThriftSetStpPortStateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_stp_port_state_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetStpPortStateResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_set_stp_port_state_result_class_init (switch_sai_rpcSaiThriftSetStpPortStateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_stp_port_state_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_stp_port_state_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_stp_port_state_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_stp_port_state_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_stp_port_state_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_STP_PORT_STATE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_stp_port_state_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetStpPortStateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_stp_port_state_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetStpPortStateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_stp_port_state_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetStpPortStateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetStpPortStateArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_STP_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_PORT_ID
};

/* reads a switch_sai_rpc_sai_thrift_get_stp_port_state_args object */
static gint32
switch_sai_rpc_sai_thrift_get_stp_port_state_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetStpPortStateArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->stp_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_stp_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->port_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_port_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_stp_port_state_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetStpPortStateArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetStpPortStateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "stp_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->stp_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "port_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->port_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_stp_port_state_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetStpPortStateArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_STP_ID:
      self->stp_id = g_value_get_int64 (value);
      self->__isset_stp_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_PORT_ID:
      self->port_id = g_value_get_int64 (value);
      self->__isset_port_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_stp_port_state_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetStpPortStateArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_STP_ID:
      g_value_set_int64 (value, self->stp_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_PORT_ID:
      g_value_set_int64 (value, self->port_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_stp_port_state_args_instance_init (switch_sai_rpcSaiThriftGetStpPortStateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->stp_id = 0;
  object->__isset_stp_id = FALSE;
  object->port_id = 0;
  object->__isset_port_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_stp_port_state_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetStpPortStateArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_get_stp_port_state_args_class_init (switch_sai_rpcSaiThriftGetStpPortStateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_stp_port_state_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_stp_port_state_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_stp_port_state_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_stp_port_state_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_stp_port_state_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_STP_ID,
     g_param_spec_int64 ("stp_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_ARGS_PORT_ID,
     g_param_spec_int64 ("port_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_stp_port_state_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetStpPortStateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_stp_port_state_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetStpPortStateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_stp_port_state_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetStpPortStateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetStpPortStateResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_get_stp_port_state_result object */
static gint32
switch_sai_rpc_sai_thrift_get_stp_port_state_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetStpPortStateResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_stp_port_state_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetStpPortStateResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetStpPortStateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BYTE, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_stp_port_state_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetStpPortStateResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_stp_port_state_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetStpPortStateResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_stp_port_state_result_instance_init (switch_sai_rpcSaiThriftGetStpPortStateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_stp_port_state_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetStpPortStateResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_get_stp_port_state_result_class_init (switch_sai_rpcSaiThriftGetStpPortStateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_stp_port_state_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_stp_port_state_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_stp_port_state_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_stp_port_state_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_stp_port_state_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_STP_PORT_STATE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_stp_port_state_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetStpPortStateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_stp_port_state_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetStpPortStateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_stp_port_state_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetStpPortStateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateNeighborEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_neighbor_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateNeighborEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_neighbor_entry), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_neighbor_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem38 = NULL;
              if ( _elem38 != NULL)
              {
                g_object_unref (_elem38);
              }
              _elem38 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem38), protocol, error)) < 0)
              {
                g_object_unref (_elem38);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem38);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateNeighborEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateNeighborEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_neighbor_entry", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_neighbor_entry), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i39;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i39 = 0; i39 < this_object->thrift_attr_list->len; i39++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i39))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNeighborEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY:
      if (self->thrift_neighbor_entry != NULL)
        g_object_unref (self->thrift_neighbor_entry);
      self->thrift_neighbor_entry = g_value_dup_object (value);
      self->__isset_thrift_neighbor_entry = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNeighborEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY:
      g_value_set_object (value, self->thrift_neighbor_entry);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_instance_init (switch_sai_rpcSaiThriftCreateNeighborEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_neighbor_entry = g_object_new (TYPE_SAI_THRIFT_NEIGHBOR_ENTRY_T, NULL);
  object->__isset_thrift_neighbor_entry = FALSE;
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateNeighborEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_neighbor_entry != NULL)
  {
    g_object_unref(tobject->thrift_neighbor_entry);
    tobject->thrift_neighbor_entry = NULL;
  }
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_class_init (switch_sai_rpcSaiThriftCreateNeighborEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_neighbor_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_neighbor_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_neighbor_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_neighbor_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_neighbor_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY,
     g_param_spec_object ("thrift_neighbor_entry",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_NEIGHBOR_ENTRY_T,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_neighbor_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateNeighborEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_neighbor_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateNeighborEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_neighbor_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateNeighborEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateNeighborEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_neighbor_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateNeighborEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateNeighborEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateNeighborEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNeighborEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateNeighborEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_instance_init (switch_sai_rpcSaiThriftCreateNeighborEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateNeighborEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_class_init (switch_sai_rpcSaiThriftCreateNeighborEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_neighbor_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_neighbor_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_neighbor_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_neighbor_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_neighbor_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_NEIGHBOR_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_neighbor_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateNeighborEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_neighbor_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateNeighborEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_neighbor_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateNeighborEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNeighborEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY
};

/* reads a switch_sai_rpc_sai_thrift_remove_neighbor_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNeighborEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_neighbor_entry), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_neighbor_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNeighborEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNeighborEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_neighbor_entry", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_neighbor_entry), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNeighborEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY:
      if (self->thrift_neighbor_entry != NULL)
        g_object_unref (self->thrift_neighbor_entry);
      self->thrift_neighbor_entry = g_value_dup_object (value);
      self->__isset_thrift_neighbor_entry = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNeighborEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY:
      g_value_set_object (value, self->thrift_neighbor_entry);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_instance_init (switch_sai_rpcSaiThriftRemoveNeighborEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_neighbor_entry = g_object_new (TYPE_SAI_THRIFT_NEIGHBOR_ENTRY_T, NULL);
  object->__isset_thrift_neighbor_entry = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNeighborEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_neighbor_entry != NULL)
  {
    g_object_unref(tobject->thrift_neighbor_entry);
    tobject->thrift_neighbor_entry = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_class_init (switch_sai_rpcSaiThriftRemoveNeighborEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_ARGS_THRIFT_NEIGHBOR_ENTRY,
     g_param_spec_object ("thrift_neighbor_entry",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_NEIGHBOR_ENTRY_T,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNeighborEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNeighborEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_neighbor_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNeighborEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveNeighborEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_neighbor_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveNeighborEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveNeighborEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveNeighborEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNeighborEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveNeighborEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_instance_init (switch_sai_rpcSaiThriftRemoveNeighborEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveNeighborEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_class_init (switch_sai_rpcSaiThriftRemoveNeighborEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_NEIGHBOR_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveNeighborEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveNeighborEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_neighbor_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveNeighborEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a switch_sai_rpc_sai_thrift_get_switch_attribute_args object */
static gint32
switch_sai_rpc_sai_thrift_get_switch_attribute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetSwitchAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_switch_attribute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetSwitchAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetSwitchAttributeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
switch_sai_rpc_sai_thrift_get_switch_attribute_args_instance_init (switch_sai_rpcSaiThriftGetSwitchAttributeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
switch_sai_rpc_sai_thrift_get_switch_attribute_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetSwitchAttributeArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_get_switch_attribute_args_class_init (switch_sai_rpcSaiThriftGetSwitchAttributeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_switch_attribute_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_switch_attribute_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_switch_attribute_args_finalize;
}

GType
switch_sai_rpc_sai_thrift_get_switch_attribute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetSwitchAttributeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_switch_attribute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetSwitchAttributeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_switch_attribute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetSwitchAttributeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetSwitchAttributeResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_get_switch_attribute_result object */
static gint32
switch_sai_rpc_sai_thrift_get_switch_attribute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetSwitchAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_switch_attribute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetSwitchAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetSwitchAttributeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_switch_attribute_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetSwitchAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_switch_attribute_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetSwitchAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_switch_attribute_result_instance_init (switch_sai_rpcSaiThriftGetSwitchAttributeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_LIST_T, NULL);
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_switch_attribute_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetSwitchAttributeResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_get_switch_attribute_result_class_init (switch_sai_rpcSaiThriftGetSwitchAttributeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_switch_attribute_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_switch_attribute_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_switch_attribute_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_switch_attribute_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_switch_attribute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_SWITCH_ATTRIBUTE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ATTRIBUTE_LIST_T,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_switch_attribute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetSwitchAttributeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_switch_attribute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetSwitchAttributeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_switch_attribute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetSwitchAttributeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftSetSwitchAttributeArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS_ATTRIBUTE
};

/* reads a switch_sai_rpc_sai_thrift_set_switch_attribute_args object */
static gint32
switch_sai_rpc_sai_thrift_set_switch_attribute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetSwitchAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->attribute), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_attribute = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_switch_attribute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetSwitchAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetSwitchAttributeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "attribute", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->attribute), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_switch_attribute_args_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetSwitchAttributeArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS_ATTRIBUTE:
      if (self->attribute != NULL)
        g_object_unref (self->attribute);
      self->attribute = g_value_dup_object (value);
      self->__isset_attribute = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_switch_attribute_args_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetSwitchAttributeArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS_ATTRIBUTE:
      g_value_set_object (value, self->attribute);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_switch_attribute_args_instance_init (switch_sai_rpcSaiThriftSetSwitchAttributeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->attribute = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
  object->__isset_attribute = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_switch_attribute_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetSwitchAttributeArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->attribute != NULL)
  {
    g_object_unref(tobject->attribute);
    tobject->attribute = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_set_switch_attribute_args_class_init (switch_sai_rpcSaiThriftSetSwitchAttributeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_switch_attribute_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_switch_attribute_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_switch_attribute_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_switch_attribute_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_switch_attribute_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_ARGS_ATTRIBUTE,
     g_param_spec_object ("attribute",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ATTRIBUTE_T,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_switch_attribute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetSwitchAttributeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_switch_attribute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetSwitchAttributeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_switch_attribute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetSwitchAttributeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftSetSwitchAttributeResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_set_switch_attribute_result object */
static gint32
switch_sai_rpc_sai_thrift_set_switch_attribute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetSwitchAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_switch_attribute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetSwitchAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetSwitchAttributeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_switch_attribute_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetSwitchAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_switch_attribute_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetSwitchAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_switch_attribute_result_instance_init (switch_sai_rpcSaiThriftSetSwitchAttributeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_switch_attribute_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetSwitchAttributeResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_set_switch_attribute_result_class_init (switch_sai_rpcSaiThriftSetSwitchAttributeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_switch_attribute_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_switch_attribute_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_switch_attribute_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_switch_attribute_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_switch_attribute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_SWITCH_ATTRIBUTE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_switch_attribute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetSwitchAttributeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_switch_attribute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetSwitchAttributeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_switch_attribute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetSwitchAttributeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateHostifArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_hostif_args object */
static gint32
switch_sai_rpc_sai_thrift_create_hostif_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateHostifArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem40 = NULL;
              if ( _elem40 != NULL)
              {
                g_object_unref (_elem40);
              }
              _elem40 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem40), protocol, error)) < 0)
              {
                g_object_unref (_elem40);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem40);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_hostif_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateHostifArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateHostifArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i41;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i41 = 0; i41 < this_object->thrift_attr_list->len; i41++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i41))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_hostif_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_args_instance_init (switch_sai_rpcSaiThriftCreateHostifArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateHostifArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_args_class_init (switch_sai_rpcSaiThriftCreateHostifArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_hostif_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_hostif_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_hostif_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_hostif_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_hostif_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_hostif_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateHostifArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_hostif_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateHostifArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_hostif_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateHostifArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateHostifResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_hostif_result object */
static gint32
switch_sai_rpc_sai_thrift_create_hostif_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateHostifResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_hostif_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateHostifResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateHostifResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_hostif_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_result_instance_init (switch_sai_rpcSaiThriftCreateHostifResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateHostifResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_hostif_result_class_init (switch_sai_rpcSaiThriftCreateHostifResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_hostif_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_hostif_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_hostif_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_hostif_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_hostif_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_hostif_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateHostifResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_hostif_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateHostifResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_hostif_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateHostifResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveHostifArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS_HIF_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_hostif_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_hostif_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveHostifArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->hif_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_hif_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_hostif_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveHostifArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveHostifArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hif_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->hif_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS_HIF_ID:
      self->hif_id = g_value_get_int64 (value);
      self->__isset_hif_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS_HIF_ID:
      g_value_set_int64 (value, self->hif_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_args_instance_init (switch_sai_rpcSaiThriftRemoveHostifArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->hif_id = 0;
  object->__isset_hif_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveHostifArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_args_class_init (switch_sai_rpcSaiThriftRemoveHostifArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_hostif_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_hostif_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_hostif_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_hostif_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_hostif_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_ARGS_HIF_ID,
     g_param_spec_int64 ("hif_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_hostif_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveHostifArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveHostifArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveHostifArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveHostifResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_hostif_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_hostif_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveHostifResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_hostif_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveHostifResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveHostifResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_result_instance_init (switch_sai_rpcSaiThriftRemoveHostifResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveHostifResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_result_class_init (switch_sai_rpcSaiThriftRemoveHostifResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_hostif_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_hostif_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_hostif_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_hostif_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_hostif_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_hostif_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveHostifResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveHostifResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveHostifResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateHostifTrapGroupArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_hostif_trap_group_args object */
static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem42 = NULL;
              if ( _elem42 != NULL)
              {
                g_object_unref (_elem42);
              }
              _elem42 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem42), protocol, error)) < 0)
              {
                g_object_unref (_elem42);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem42);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i43;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i43 = 0; i43 < this_object->thrift_attr_list->len; i43++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i43))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_set_property (GObject *object,
                                                                      guint property_id,
                                                                      const GValue *value,
                                                                      GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_get_property (GObject *object,
                                                                      guint property_id,
                                                                      GValue *value,
                                                                      GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_instance_init (switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_class_init (switch_sai_rpcSaiThriftCreateHostifTrapGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateHostifTrapGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateHostifTrapGroupResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_hostif_trap_group_result object */
static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateHostifTrapGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateHostifTrapGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateHostifTrapGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_set_property (GObject *object,
                                                                        guint property_id,
                                                                        const GValue *value,
                                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_get_property (GObject *object,
                                                                        guint property_id,
                                                                        GValue *value,
                                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_instance_init (switch_sai_rpcSaiThriftCreateHostifTrapGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateHostifTrapGroupResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_class_init (switch_sai_rpcSaiThriftCreateHostifTrapGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateHostifTrapGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS_TRAP_GROUP_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->trap_group_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_trap_group_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "trap_group_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->trap_group_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_set_property (GObject *object,
                                                                      guint property_id,
                                                                      const GValue *value,
                                                                      GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS_TRAP_GROUP_ID:
      self->trap_group_id = g_value_get_int64 (value);
      self->__isset_trap_group_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_get_property (GObject *object,
                                                                      guint property_id,
                                                                      GValue *value,
                                                                      GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS_TRAP_GROUP_ID:
      g_value_set_int64 (value, self->trap_group_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_instance_init (switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->trap_group_id = 0;
  object->__isset_trap_group_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_class_init (switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_ARGS_TRAP_GROUP_ID,
     g_param_spec_int64 ("trap_group_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveHostifTrapGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveHostifTrapGroupResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_set_property (GObject *object,
                                                                        guint property_id,
                                                                        const GValue *value,
                                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_get_property (GObject *object,
                                                                        guint property_id,
                                                                        GValue *value,
                                                                        GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_instance_init (switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_class_init (switch_sai_rpcSaiThriftRemoveHostifTrapGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_GROUP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveHostifTrapGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateHostifTrapArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_hostif_trap_args object */
static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateHostifTrapArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem44 = NULL;
              if ( _elem44 != NULL)
              {
                g_object_unref (_elem44);
              }
              _elem44 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem44), protocol, error)) < 0)
              {
                g_object_unref (_elem44);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem44);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateHostifTrapArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateHostifTrapArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i45;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i45 = 0; i45 < this_object->thrift_attr_list->len; i45++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i45))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_args_instance_init (switch_sai_rpcSaiThriftCreateHostifTrapArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateHostifTrapArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_args_class_init (switch_sai_rpcSaiThriftCreateHostifTrapArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_hostif_trap_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_hostif_trap_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_hostif_trap_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_hostif_trap_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_hostif_trap_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_hostif_trap_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateHostifTrapArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateHostifTrapResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_hostif_trap_result object */
static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateHostifTrapResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_hostif_trap_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateHostifTrapResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateHostifTrapResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateHostifTrapResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_result_instance_init (switch_sai_rpcSaiThriftCreateHostifTrapResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_hostif_trap_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateHostifTrapResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_hostif_trap_result_class_init (switch_sai_rpcSaiThriftCreateHostifTrapResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_hostif_trap_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_hostif_trap_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_hostif_trap_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_hostif_trap_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_hostif_trap_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_HOSTIF_TRAP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_hostif_trap_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateHostifTrapResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_hostif_trap_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateHostifTrapResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveHostifTrapArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS_TRAP_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_hostif_trap_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveHostifTrapArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->trap_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_trap_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveHostifTrapArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveHostifTrapArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "trap_id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->trap_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS_TRAP_ID:
      self->trap_id = g_value_get_int (value);
      self->__isset_trap_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS_TRAP_ID:
      g_value_set_int (value, self->trap_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_instance_init (switch_sai_rpcSaiThriftRemoveHostifTrapArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->trap_id = 0;
  object->__isset_trap_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_class_init (switch_sai_rpcSaiThriftRemoveHostifTrapArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_hostif_trap_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_hostif_trap_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_hostif_trap_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_ARGS_TRAP_ID,
     g_param_spec_int ("trap_id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_hostif_trap_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveHostifTrapArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveHostifTrapResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_hostif_trap_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveHostifTrapResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveHostifTrapResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveHostifTrapResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_instance_init (switch_sai_rpcSaiThriftRemoveHostifTrapResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveHostifTrapResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_class_init (switch_sai_rpcSaiThriftRemoveHostifTrapResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_hostif_trap_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_hostif_trap_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_hostif_trap_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_hostif_trap_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_HOSTIF_TRAP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_hostif_trap_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveHostifTrapResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_hostif_trap_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveHostifTrapResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftSetHostifTrapArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_TRAP_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_THRIFT_ATTR
};

/* reads a switch_sai_rpc_sai_thrift_set_hostif_trap_args object */
static gint32
switch_sai_rpc_sai_thrift_set_hostif_trap_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetHostifTrapArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->trap_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_trap_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->thrift_attr), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_thrift_attr = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_hostif_trap_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetHostifTrapArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetHostifTrapArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "trap_id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->trap_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->thrift_attr), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_hostif_trap_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetHostifTrapArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_TRAP_ID:
      self->trap_id = g_value_get_int (value);
      self->__isset_trap_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_THRIFT_ATTR:
      if (self->thrift_attr != NULL)
        g_object_unref (self->thrift_attr);
      self->thrift_attr = g_value_dup_object (value);
      self->__isset_thrift_attr = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_hostif_trap_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetHostifTrapArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_TRAP_ID:
      g_value_set_int (value, self->trap_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_THRIFT_ATTR:
      g_value_set_object (value, self->thrift_attr);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_hostif_trap_args_instance_init (switch_sai_rpcSaiThriftSetHostifTrapArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->trap_id = 0;
  object->__isset_trap_id = FALSE;
  object->thrift_attr = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
  object->__isset_thrift_attr = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_hostif_trap_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetHostifTrapArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr != NULL)
  {
    g_object_unref(tobject->thrift_attr);
    tobject->thrift_attr = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_set_hostif_trap_args_class_init (switch_sai_rpcSaiThriftSetHostifTrapArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_hostif_trap_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_hostif_trap_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_hostif_trap_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_hostif_trap_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_hostif_trap_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_TRAP_ID,
     g_param_spec_int ("trap_id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_ARGS_THRIFT_ATTR,
     g_param_spec_object ("thrift_attr",
                         NULL,
                         NULL,
                         TYPE_SAI_THRIFT_ATTRIBUTE_T,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_hostif_trap_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetHostifTrapArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_hostif_trap_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetHostifTrapArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_hostif_trap_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetHostifTrapArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftSetHostifTrapResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_set_hostif_trap_result object */
static gint32
switch_sai_rpc_sai_thrift_set_hostif_trap_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftSetHostifTrapResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_set_hostif_trap_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftSetHostifTrapResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftSetHostifTrapResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_set_hostif_trap_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetHostifTrapResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_set_hostif_trap_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftSetHostifTrapResult *self = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_set_hostif_trap_result_instance_init (switch_sai_rpcSaiThriftSetHostifTrapResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_set_hostif_trap_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftSetHostifTrapResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_set_hostif_trap_result_class_init (switch_sai_rpcSaiThriftSetHostifTrapResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_set_hostif_trap_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_set_hostif_trap_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_set_hostif_trap_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_set_hostif_trap_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_set_hostif_trap_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_SET_HOSTIF_TRAP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_set_hostif_trap_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftSetHostifTrapResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_set_hostif_trap_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftSetHostifTrapResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_set_hostif_trap_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftSetHostifTrapResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateAclTableArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_acl_table_args object */
static gint32
switch_sai_rpc_sai_thrift_create_acl_table_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateAclTableArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem46 = NULL;
              if ( _elem46 != NULL)
              {
                g_object_unref (_elem46);
              }
              _elem46 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem46), protocol, error)) < 0)
              {
                g_object_unref (_elem46);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem46);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_acl_table_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateAclTableArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateAclTableArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i47;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i47 = 0; i47 < this_object->thrift_attr_list->len; i47++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i47))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_acl_table_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclTableArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_table_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclTableArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_acl_table_args_instance_init (switch_sai_rpcSaiThriftCreateAclTableArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_acl_table_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateAclTableArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_table_args_class_init (switch_sai_rpcSaiThriftCreateAclTableArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_acl_table_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_acl_table_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_acl_table_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_acl_table_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_acl_table_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_acl_table_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateAclTableArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_acl_table_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateAclTableArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_acl_table_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateAclTableArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateAclTableResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_acl_table_result object */
static gint32
switch_sai_rpc_sai_thrift_create_acl_table_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateAclTableResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_acl_table_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateAclTableResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateAclTableResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_acl_table_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclTableResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_table_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclTableResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_acl_table_result_instance_init (switch_sai_rpcSaiThriftCreateAclTableResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_acl_table_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateAclTableResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_acl_table_result_class_init (switch_sai_rpcSaiThriftCreateAclTableResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_acl_table_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_acl_table_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_acl_table_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_acl_table_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_acl_table_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_TABLE_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_acl_table_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateAclTableResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_acl_table_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateAclTableResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_acl_table_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateAclTableResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteAclTableArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS_ACL_TABLE_ID
};

/* reads a switch_sai_rpc_sai_thrift_delete_acl_table_args object */
static gint32
switch_sai_rpc_sai_thrift_delete_acl_table_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteAclTableArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->acl_table_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_acl_table_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_acl_table_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteAclTableArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteAclTableArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "acl_table_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->acl_table_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_acl_table_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclTableArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS_ACL_TABLE_ID:
      self->acl_table_id = g_value_get_int64 (value);
      self->__isset_acl_table_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_acl_table_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclTableArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS_ACL_TABLE_ID:
      g_value_set_int64 (value, self->acl_table_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_table_args_instance_init (switch_sai_rpcSaiThriftDeleteAclTableArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->acl_table_id = 0;
  object->__isset_acl_table_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_table_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteAclTableArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_acl_table_args_class_init (switch_sai_rpcSaiThriftDeleteAclTableArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_acl_table_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_acl_table_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_acl_table_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_acl_table_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_acl_table_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_ARGS_ACL_TABLE_ID,
     g_param_spec_int64 ("acl_table_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_acl_table_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteAclTableArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_acl_table_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteAclTableArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_acl_table_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteAclTableArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteAclTableResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_delete_acl_table_result object */
static gint32
switch_sai_rpc_sai_thrift_delete_acl_table_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteAclTableResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_acl_table_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteAclTableResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteAclTableResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_acl_table_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclTableResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_acl_table_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclTableResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_table_result_instance_init (switch_sai_rpcSaiThriftDeleteAclTableResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_table_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteAclTableResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_acl_table_result_class_init (switch_sai_rpcSaiThriftDeleteAclTableResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_acl_table_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_acl_table_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_acl_table_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_acl_table_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_acl_table_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_TABLE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_acl_table_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteAclTableResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_acl_table_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteAclTableResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_acl_table_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteAclTableResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateAclEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_acl_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_create_acl_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateAclEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem48 = NULL;
              if ( _elem48 != NULL)
              {
                g_object_unref (_elem48);
              }
              _elem48 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem48), protocol, error)) < 0)
              {
                g_object_unref (_elem48);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem48);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_acl_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateAclEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateAclEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i49;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i49 = 0; i49 < this_object->thrift_attr_list->len; i49++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i49))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_acl_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_acl_entry_args_instance_init (switch_sai_rpcSaiThriftCreateAclEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_acl_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateAclEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_entry_args_class_init (switch_sai_rpcSaiThriftCreateAclEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_acl_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_acl_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_acl_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_acl_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_acl_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_acl_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateAclEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_acl_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateAclEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_acl_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateAclEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateAclEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_acl_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_create_acl_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateAclEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_acl_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateAclEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateAclEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_acl_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_acl_entry_result_instance_init (switch_sai_rpcSaiThriftCreateAclEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_acl_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateAclEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_acl_entry_result_class_init (switch_sai_rpcSaiThriftCreateAclEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_acl_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_acl_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_acl_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_acl_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_acl_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_ENTRY_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_acl_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateAclEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_acl_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateAclEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_acl_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateAclEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteAclEntryArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS_ACL_ENTRY
};

/* reads a switch_sai_rpc_sai_thrift_delete_acl_entry_args object */
static gint32
switch_sai_rpc_sai_thrift_delete_acl_entry_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteAclEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->acl_entry, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_acl_entry = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_acl_entry_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteAclEntryArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteAclEntryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "acl_entry", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->acl_entry, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_acl_entry_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS_ACL_ENTRY:
      self->acl_entry = g_value_get_int64 (value);
      self->__isset_acl_entry = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_acl_entry_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclEntryArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS_ACL_ENTRY:
      g_value_set_int64 (value, self->acl_entry);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_entry_args_instance_init (switch_sai_rpcSaiThriftDeleteAclEntryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->acl_entry = 0;
  object->__isset_acl_entry = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_entry_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteAclEntryArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_acl_entry_args_class_init (switch_sai_rpcSaiThriftDeleteAclEntryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_acl_entry_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_acl_entry_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_acl_entry_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_acl_entry_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_acl_entry_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_ARGS_ACL_ENTRY,
     g_param_spec_int64 ("acl_entry",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_acl_entry_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteAclEntryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_acl_entry_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteAclEntryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_acl_entry_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteAclEntryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteAclEntryResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_delete_acl_entry_result object */
static gint32
switch_sai_rpc_sai_thrift_delete_acl_entry_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteAclEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_acl_entry_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteAclEntryResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteAclEntryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_acl_entry_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_acl_entry_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclEntryResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_entry_result_instance_init (switch_sai_rpcSaiThriftDeleteAclEntryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_entry_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteAclEntryResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_acl_entry_result_class_init (switch_sai_rpcSaiThriftDeleteAclEntryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_acl_entry_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_acl_entry_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_acl_entry_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_acl_entry_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_acl_entry_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_ENTRY_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_acl_entry_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteAclEntryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_acl_entry_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteAclEntryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_acl_entry_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteAclEntryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateAclCounterArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_acl_counter_args object */
static gint32
switch_sai_rpc_sai_thrift_create_acl_counter_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateAclCounterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem50 = NULL;
              if ( _elem50 != NULL)
              {
                g_object_unref (_elem50);
              }
              _elem50 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem50), protocol, error)) < 0)
              {
                g_object_unref (_elem50);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem50);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_acl_counter_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateAclCounterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateAclCounterArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i51;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i51 = 0; i51 < this_object->thrift_attr_list->len; i51++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i51))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_acl_counter_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclCounterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_counter_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclCounterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_acl_counter_args_instance_init (switch_sai_rpcSaiThriftCreateAclCounterArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_acl_counter_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateAclCounterArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_counter_args_class_init (switch_sai_rpcSaiThriftCreateAclCounterArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_acl_counter_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_acl_counter_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_acl_counter_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_acl_counter_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_acl_counter_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_acl_counter_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateAclCounterArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_acl_counter_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateAclCounterArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_acl_counter_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateAclCounterArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateAclCounterResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_acl_counter_result object */
static gint32
switch_sai_rpc_sai_thrift_create_acl_counter_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateAclCounterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_acl_counter_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateAclCounterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateAclCounterResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_acl_counter_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclCounterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_acl_counter_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateAclCounterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_acl_counter_result_instance_init (switch_sai_rpcSaiThriftCreateAclCounterResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_acl_counter_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateAclCounterResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_acl_counter_result_class_init (switch_sai_rpcSaiThriftCreateAclCounterResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_acl_counter_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_acl_counter_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_acl_counter_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_acl_counter_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_acl_counter_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_ACL_COUNTER_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_acl_counter_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateAclCounterResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_acl_counter_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateAclCounterResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_acl_counter_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateAclCounterResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteAclCounterArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS_ACL_COUNTER_ID
};

/* reads a switch_sai_rpc_sai_thrift_delete_acl_counter_args object */
static gint32
switch_sai_rpc_sai_thrift_delete_acl_counter_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteAclCounterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->acl_counter_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_acl_counter_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_acl_counter_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteAclCounterArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteAclCounterArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "acl_counter_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->acl_counter_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_acl_counter_args_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclCounterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS_ACL_COUNTER_ID:
      self->acl_counter_id = g_value_get_int64 (value);
      self->__isset_acl_counter_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_acl_counter_args_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclCounterArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS_ACL_COUNTER_ID:
      g_value_set_int64 (value, self->acl_counter_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_counter_args_instance_init (switch_sai_rpcSaiThriftDeleteAclCounterArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->acl_counter_id = 0;
  object->__isset_acl_counter_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_counter_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteAclCounterArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_acl_counter_args_class_init (switch_sai_rpcSaiThriftDeleteAclCounterArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_acl_counter_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_acl_counter_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_acl_counter_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_acl_counter_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_acl_counter_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_ARGS_ACL_COUNTER_ID,
     g_param_spec_int64 ("acl_counter_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_acl_counter_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteAclCounterArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_acl_counter_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteAclCounterArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_acl_counter_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteAclCounterArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftDeleteAclCounterResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_delete_acl_counter_result object */
static gint32
switch_sai_rpc_sai_thrift_delete_acl_counter_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftDeleteAclCounterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_delete_acl_counter_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftDeleteAclCounterResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftDeleteAclCounterResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_delete_acl_counter_result_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclCounterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_delete_acl_counter_result_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftDeleteAclCounterResult *self = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_counter_result_instance_init (switch_sai_rpcSaiThriftDeleteAclCounterResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_delete_acl_counter_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftDeleteAclCounterResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_delete_acl_counter_result_class_init (switch_sai_rpcSaiThriftDeleteAclCounterResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_delete_acl_counter_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_delete_acl_counter_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_delete_acl_counter_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_delete_acl_counter_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_delete_acl_counter_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_DELETE_ACL_COUNTER_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_delete_acl_counter_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftDeleteAclCounterResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_delete_acl_counter_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftDeleteAclCounterResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_delete_acl_counter_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftDeleteAclCounterResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetAclCounterAttributeArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_ACL_COUNTER_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_THRIFT_ATTR_IDS
};

/* reads a switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args object */
static gint32
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetAclCounterAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->acl_counter_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_acl_counter_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem52 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem52, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->thrift_attr_ids, _elem52, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_ids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetAclCounterAttributeArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetAclCounterAttributeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "acl_counter_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->acl_counter_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_ids", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i53;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->thrift_attr_ids->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i53 = 0; i53 < this_object->thrift_attr_ids->len; i53++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->thrift_attr_ids, gint32, i53)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_set_property (GObject *object,
                                                                       guint property_id,
                                                                       const GValue *value,
                                                                       GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetAclCounterAttributeArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_ACL_COUNTER_ID:
      self->acl_counter_id = g_value_get_int64 (value);
      self->__isset_acl_counter_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_THRIFT_ATTR_IDS:
      if (self->thrift_attr_ids != NULL)
        g_array_unref (self->thrift_attr_ids);
      self->thrift_attr_ids = g_value_dup_boxed (value);
      self->__isset_thrift_attr_ids = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_get_property (GObject *object,
                                                                       guint property_id,
                                                                       GValue *value,
                                                                       GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetAclCounterAttributeArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_ACL_COUNTER_ID:
      g_value_set_int64 (value, self->acl_counter_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_THRIFT_ATTR_IDS:
      g_value_set_boxed (value, self->thrift_attr_ids);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_instance_init (switch_sai_rpcSaiThriftGetAclCounterAttributeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->acl_counter_id = 0;
  object->__isset_acl_counter_id = FALSE;
  object->thrift_attr_ids = g_array_new (0, 1, sizeof (gint32));
  object->__isset_thrift_attr_ids = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetAclCounterAttributeArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_ids != NULL)
  {
    g_array_unref (tobject->thrift_attr_ids);
    tobject->thrift_attr_ids = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_class_init (switch_sai_rpcSaiThriftGetAclCounterAttributeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_ACL_COUNTER_ID,
     g_param_spec_int64 ("acl_counter_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_ARGS_THRIFT_ATTR_IDS,
     g_param_spec_boxed ("thrift_attr_ids",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetAclCounterAttributeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetAclCounterAttributeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_acl_counter_attribute_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetAclCounterAttributeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetAclCounterAttributeResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result object */
static gint32
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetAclCounterAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_value_t * _elem54 = NULL;
              if ( _elem54 != NULL)
              {
                g_object_unref (_elem54);
              }
              _elem54 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_VALUE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem54), protocol, error)) < 0)
              {
                g_object_unref (_elem54);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem54);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetAclCounterAttributeResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetAclCounterAttributeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i55;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i55 = 0; i55 < this_object->success->len; i55++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i55))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_set_property (GObject *object,
                                                                         guint property_id,
                                                                         const GValue *value,
                                                                         GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetAclCounterAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_get_property (GObject *object,
                                                                         guint property_id,
                                                                         GValue *value,
                                                                         GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetAclCounterAttributeResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_instance_init (switch_sai_rpcSaiThriftGetAclCounterAttributeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetAclCounterAttributeResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_class_init (switch_sai_rpcSaiThriftGetAclCounterAttributeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_ACL_COUNTER_ATTRIBUTE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetAclCounterAttributeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetAclCounterAttributeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_acl_counter_attribute_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetAclCounterAttributeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateMirrorSessionArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_mirror_session_args object */
static gint32
switch_sai_rpc_sai_thrift_create_mirror_session_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateMirrorSessionArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem56 = NULL;
              if ( _elem56 != NULL)
              {
                g_object_unref (_elem56);
              }
              _elem56 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem56), protocol, error)) < 0)
              {
                g_object_unref (_elem56);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem56);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_mirror_session_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateMirrorSessionArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateMirrorSessionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i57;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i57 = 0; i57 < this_object->thrift_attr_list->len; i57++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i57))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_mirror_session_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateMirrorSessionArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_mirror_session_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateMirrorSessionArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_mirror_session_args_instance_init (switch_sai_rpcSaiThriftCreateMirrorSessionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_mirror_session_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateMirrorSessionArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_mirror_session_args_class_init (switch_sai_rpcSaiThriftCreateMirrorSessionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_mirror_session_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_mirror_session_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_mirror_session_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_mirror_session_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_mirror_session_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_mirror_session_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateMirrorSessionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_mirror_session_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateMirrorSessionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_mirror_session_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateMirrorSessionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreateMirrorSessionResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_mirror_session_result object */
static gint32
switch_sai_rpc_sai_thrift_create_mirror_session_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreateMirrorSessionResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_mirror_session_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreateMirrorSessionResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreateMirrorSessionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_mirror_session_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateMirrorSessionResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_mirror_session_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreateMirrorSessionResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_mirror_session_result_instance_init (switch_sai_rpcSaiThriftCreateMirrorSessionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_mirror_session_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreateMirrorSessionResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_mirror_session_result_class_init (switch_sai_rpcSaiThriftCreateMirrorSessionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_mirror_session_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_mirror_session_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_mirror_session_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_mirror_session_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_mirror_session_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_MIRROR_SESSION_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_mirror_session_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreateMirrorSessionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_mirror_session_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreateMirrorSessionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_mirror_session_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreateMirrorSessionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveMirrorSessionArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS_SESSION_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_mirror_session_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_mirror_session_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveMirrorSessionArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->session_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_session_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_mirror_session_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveMirrorSessionArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveMirrorSessionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "session_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->session_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_mirror_session_args_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveMirrorSessionArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS_SESSION_ID:
      self->session_id = g_value_get_int64 (value);
      self->__isset_session_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_mirror_session_args_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveMirrorSessionArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS_SESSION_ID:
      g_value_set_int64 (value, self->session_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_mirror_session_args_instance_init (switch_sai_rpcSaiThriftRemoveMirrorSessionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->session_id = 0;
  object->__isset_session_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_mirror_session_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveMirrorSessionArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_mirror_session_args_class_init (switch_sai_rpcSaiThriftRemoveMirrorSessionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_mirror_session_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_mirror_session_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_mirror_session_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_mirror_session_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_mirror_session_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_ARGS_SESSION_ID,
     g_param_spec_int64 ("session_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_mirror_session_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveMirrorSessionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_mirror_session_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveMirrorSessionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_mirror_session_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveMirrorSessionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemoveMirrorSessionResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_mirror_session_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_mirror_session_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemoveMirrorSessionResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_mirror_session_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemoveMirrorSessionResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemoveMirrorSessionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_mirror_session_result_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveMirrorSessionResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_mirror_session_result_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemoveMirrorSessionResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_mirror_session_result_instance_init (switch_sai_rpcSaiThriftRemoveMirrorSessionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_mirror_session_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemoveMirrorSessionResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_mirror_session_result_class_init (switch_sai_rpcSaiThriftRemoveMirrorSessionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_mirror_session_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_mirror_session_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_mirror_session_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_mirror_session_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_mirror_session_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_MIRROR_SESSION_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_mirror_session_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemoveMirrorSessionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_mirror_session_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemoveMirrorSessionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_mirror_session_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemoveMirrorSessionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreatePolicerArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS_THRIFT_ATTR_LIST
};

/* reads a switch_sai_rpc_sai_thrift_create_policer_args object */
static gint32
switch_sai_rpc_sai_thrift_create_policer_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreatePolicerArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              sai_thrift_attribute_t * _elem58 = NULL;
              if ( _elem58 != NULL)
              {
                g_object_unref (_elem58);
              }
              _elem58 = g_object_new (TYPE_SAI_THRIFT_ATTRIBUTE_T, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem58), protocol, error)) < 0)
              {
                g_object_unref (_elem58);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->thrift_attr_list, _elem58);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_thrift_attr_list = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_policer_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreatePolicerArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreatePolicerArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "thrift_attr_list", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i59;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) this_object->thrift_attr_list->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i59 = 0; i59 < this_object->thrift_attr_list->len; i59++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->thrift_attr_list, i59))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_policer_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreatePolicerArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS_THRIFT_ATTR_LIST:
      if (self->thrift_attr_list != NULL)
        g_ptr_array_unref (self->thrift_attr_list);
      self->thrift_attr_list = g_value_dup_boxed (value);
      self->__isset_thrift_attr_list = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_policer_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreatePolicerArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS_THRIFT_ATTR_LIST:
      g_value_set_boxed (value, self->thrift_attr_list);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_policer_args_instance_init (switch_sai_rpcSaiThriftCreatePolicerArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->thrift_attr_list = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_thrift_attr_list = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_policer_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreatePolicerArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->thrift_attr_list != NULL)
  {
    g_ptr_array_unref (tobject->thrift_attr_list);
    tobject->thrift_attr_list = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_create_policer_args_class_init (switch_sai_rpcSaiThriftCreatePolicerArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_policer_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_policer_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_policer_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_policer_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_policer_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_ARGS_THRIFT_ATTR_LIST,
     g_param_spec_boxed ("thrift_attr_list",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_policer_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreatePolicerArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_policer_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreatePolicerArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_policer_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreatePolicerArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftCreatePolicerResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_create_policer_result object */
static gint32
switch_sai_rpc_sai_thrift_create_policer_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftCreatePolicerResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_create_policer_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftCreatePolicerResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftCreatePolicerResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_create_policer_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreatePolicerResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_create_policer_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftCreatePolicerResult *self = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_create_policer_result_instance_init (switch_sai_rpcSaiThriftCreatePolicerResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_create_policer_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftCreatePolicerResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_create_policer_result_class_init (switch_sai_rpcSaiThriftCreatePolicerResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_create_policer_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_create_policer_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_create_policer_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_create_policer_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_create_policer_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_CREATE_POLICER_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_create_policer_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftCreatePolicerResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_create_policer_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftCreatePolicerResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_create_policer_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftCreatePolicerResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemovePolicerArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS_POLICER_ID
};

/* reads a switch_sai_rpc_sai_thrift_remove_policer_args object */
static gint32
switch_sai_rpc_sai_thrift_remove_policer_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemovePolicerArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->policer_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_policer_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_policer_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemovePolicerArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemovePolicerArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "policer_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->policer_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_policer_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePolicerArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS_POLICER_ID:
      self->policer_id = g_value_get_int64 (value);
      self->__isset_policer_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_policer_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePolicerArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS_POLICER_ID:
      g_value_set_int64 (value, self->policer_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_policer_args_instance_init (switch_sai_rpcSaiThriftRemovePolicerArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->policer_id = 0;
  object->__isset_policer_id = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_policer_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemovePolicerArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_policer_args_class_init (switch_sai_rpcSaiThriftRemovePolicerArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_policer_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_policer_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_policer_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_policer_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_policer_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_ARGS_POLICER_ID,
     g_param_spec_int64 ("policer_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_policer_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemovePolicerArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_policer_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemovePolicerArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_policer_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemovePolicerArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftRemovePolicerResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_remove_policer_result object */
static gint32
switch_sai_rpc_sai_thrift_remove_policer_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftRemovePolicerResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_remove_policer_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftRemovePolicerResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftRemovePolicerResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_remove_policer_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePolicerResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_remove_policer_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftRemovePolicerResult *self = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_remove_policer_result_instance_init (switch_sai_rpcSaiThriftRemovePolicerResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_remove_policer_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftRemovePolicerResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
switch_sai_rpc_sai_thrift_remove_policer_result_class_init (switch_sai_rpcSaiThriftRemovePolicerResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_remove_policer_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_remove_policer_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_remove_policer_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_remove_policer_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_remove_policer_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_REMOVE_POLICER_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_remove_policer_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftRemovePolicerResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_remove_policer_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftRemovePolicerResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_remove_policer_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftRemovePolicerResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetPolicerStatsArgsProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_POLICER_ID,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_COUNTER_IDS
};

/* reads a switch_sai_rpc_sai_thrift_get_policer_stats_args object */
static gint32
switch_sai_rpc_sai_thrift_get_policer_stats_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetPolicerStatsArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->policer_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_policer_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem60 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem60, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->counter_ids, _elem60, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_counter_ids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_policer_stats_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetPolicerStatsArgs * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetPolicerStatsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "policer_id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->policer_id, error)) < 0)
    return -1;
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "counter_ids", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i61;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) this_object->counter_ids->len, error)) < 0)
      return -1;
    xfer += ret;
    for (i61 = 0; i61 < this_object->counter_ids->len; i61++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->counter_ids, gint32, i61)), error)) < 0)
        return -1;
    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_policer_stats_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetPolicerStatsArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_POLICER_ID:
      self->policer_id = g_value_get_int64 (value);
      self->__isset_policer_id = TRUE;
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_COUNTER_IDS:
      if (self->counter_ids != NULL)
        g_array_unref (self->counter_ids);
      self->counter_ids = g_value_dup_boxed (value);
      self->__isset_counter_ids = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_policer_stats_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetPolicerStatsArgs *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_POLICER_ID:
      g_value_set_int64 (value, self->policer_id);
      break;

    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_COUNTER_IDS:
      g_value_set_boxed (value, self->counter_ids);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_policer_stats_args_instance_init (switch_sai_rpcSaiThriftGetPolicerStatsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->policer_id = 0;
  object->__isset_policer_id = FALSE;
  object->counter_ids = g_array_new (0, 1, sizeof (gint32));
  object->__isset_counter_ids = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_policer_stats_args_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetPolicerStatsArgs *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->counter_ids != NULL)
  {
    g_array_unref (tobject->counter_ids);
    tobject->counter_ids = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_get_policer_stats_args_class_init (switch_sai_rpcSaiThriftGetPolicerStatsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_policer_stats_args_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_policer_stats_args_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_policer_stats_args_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_policer_stats_args_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_policer_stats_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_POLICER_ID,
     g_param_spec_int64 ("policer_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_ARGS_COUNTER_IDS,
     g_param_spec_boxed ("counter_ids",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_policer_stats_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetPolicerStatsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_policer_stats_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetPolicerStatsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_policer_stats_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetPolicerStatsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _switch_sai_rpcSaiThriftGetPolicerStatsResultProperties
{
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT_0,
  PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT_SUCCESS
};

/* reads a switch_sai_rpc_sai_thrift_get_policer_stats_result object */
static gint32
switch_sai_rpc_sai_thrift_get_policer_stats_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  switch_sai_rpcSaiThriftGetPolicerStatsResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem62 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem62, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem62, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
switch_sai_rpc_sai_thrift_get_policer_stats_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  switch_sai_rpcSaiThriftGetPolicerStatsResult * this_object = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "switch_sai_rpcSaiThriftGetPolicerStatsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i63;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) this_object->success->len, error)) < 0)
        return -1;
      xfer += ret;
      for (i63 = 0; i63 < this_object->success->len; i63++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->success, gint64, i63)), error)) < 0)
          return -1;
      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
switch_sai_rpc_sai_thrift_get_policer_stats_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetPolicerStatsResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
switch_sai_rpc_sai_thrift_get_policer_stats_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  switch_sai_rpcSaiThriftGetPolicerStatsResult *self = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
switch_sai_rpc_sai_thrift_get_policer_stats_result_instance_init (switch_sai_rpcSaiThriftGetPolicerStatsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint64));
  object->__isset_success = FALSE;
}

static void 
switch_sai_rpc_sai_thrift_get_policer_stats_result_finalize (GObject *object)
{
  switch_sai_rpcSaiThriftGetPolicerStatsResult *tobject = SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
}

static void
switch_sai_rpc_sai_thrift_get_policer_stats_result_class_init (switch_sai_rpcSaiThriftGetPolicerStatsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = switch_sai_rpc_sai_thrift_get_policer_stats_result_read;
  struct_class->write = switch_sai_rpc_sai_thrift_get_policer_stats_result_write;

  gobject_class->finalize = switch_sai_rpc_sai_thrift_get_policer_stats_result_finalize;
  gobject_class->get_property = switch_sai_rpc_sai_thrift_get_policer_stats_result_get_property;
  gobject_class->set_property = switch_sai_rpc_sai_thrift_get_policer_stats_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWITCH_SAI_RPC_SAI_THRIFT_GET_POLICER_STATS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
switch_sai_rpc_sai_thrift_get_policer_stats_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (switch_sai_rpcSaiThriftGetPolicerStatsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) switch_sai_rpc_sai_thrift_get_policer_stats_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (switch_sai_rpcSaiThriftGetPolicerStatsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) switch_sai_rpc_sai_thrift_get_policer_stats_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "switch_sai_rpcSaiThriftGetPolicerStatsResultType",
                                   &type_info, 0);
  }

  return type;
}

